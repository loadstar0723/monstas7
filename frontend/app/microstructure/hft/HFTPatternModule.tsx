'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { safeFixed, safePrice, safeAmount, safePercent, safeMillion, safeThousand } from '@/lib/safeFormat'
import WebSocketManager from '@/lib/websocketManager'
import CoinSelector from './components/CoinSelector'
import ConceptGuide from './components/ConceptGuide'
import AlgoActivityHeatmap from './components/AlgoActivityHeatmap'
import PatternClassifier from './components/PatternClassifier'
import BotBehaviorAnalysis from './components/BotBehaviorAnalysis'
import StrategyInference from './components/StrategyInference'
import MarketManipulationDetector from './components/MarketManipulationDetector'
import TradingStrategy from './components/TradingStrategy'
import VolumeProfile from './components/VolumeProfile'
import PerformanceMetrics from './components/PerformanceMetrics'
import { ChevronUpIcon } from '@heroicons/react/24/outline'

// 10Í∞ú Ï£ºÏöî ÏΩîÏù∏
const SUPPORTED_COINS = [
  { symbol: 'BTCUSDT', name: 'Bitcoin', icon: '‚Çø', color: 'orange' },
  { symbol: 'ETHUSDT', name: 'Ethereum', icon: 'Œû', color: 'blue' },
  { symbol: 'BNBUSDT', name: 'BNB', icon: 'üü°', color: 'yellow' },
  { symbol: 'SOLUSDT', name: 'Solana', icon: '‚óé', color: 'purple' },
  { symbol: 'XRPUSDT', name: 'XRP', icon: '‚úï', color: 'gray' },
  { symbol: 'ADAUSDT', name: 'Cardano', icon: '‚Ç≥', color: 'blue' },
  { symbol: 'DOGEUSDT', name: 'Dogecoin', icon: '√ê', color: 'yellow' },
  { symbol: 'AVAXUSDT', name: 'Avalanche', icon: 'üî∫', color: 'red' },
  { symbol: 'MATICUSDT', name: 'Polygon', icon: '‚¨£', color: 'purple' },
  { symbol: 'DOTUSDT', name: 'Polkadot', icon: '‚óè', color: 'pink' }
]

// HFT Ìå®ÌÑ¥ ÌÉÄÏûÖ Ï†ïÏùò
interface HFTPattern {
  timestamp: number
  type: 'market_making' | 'arbitrage' | 'momentum' | 'scalping' | 'spoofing'
  confidence: number
  volume: number
  price: number
  impact: 'low' | 'medium' | 'high'
}

// Í±∞Îûò Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ
interface TradeData {
  price: number
  quantity: number
  time: number
  isBuyerMaker: boolean
  aggTradeId: number
}

export default function HFTPatternModule() {
  const [selectedCoin, setSelectedCoin] = useState('BTCUSDT')
  const [currentPrice, setCurrentPrice] = useState(0)
  const [volume24h, setVolume24h] = useState(0)
  const [priceChange24h, setPriceChange24h] = useState(0)
  const [trades, setTrades] = useState<TradeData[]>([])
  const [patterns, setPatterns] = useState<HFTPattern[]>([])
  const [orderbook, setOrderbook] = useState<any>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  const wsManager = useRef(WebSocketManager.getInstance())
  const tradesHistoryRef = useRef<TradeData[]>([])
  const patternsHistoryRef = useRef<HFTPattern[]>([])
  const patternDetectorRef = useRef<any>(null)
  
  // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  const loadInitialData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      
      // 24ÏãúÍ∞Ñ ÌÜµÍ≥Ñ
      const ticker24hrResponse = await fetch(`/api/binance/ticker/24hr?symbol=${selectedCoin}`)
      if (ticker24hrResponse.ok) {
        const ticker24hrData = await ticker24hrResponse.json()
        setCurrentPrice(parseFloat(ticker24hrData.lastPrice) || 0)
        setVolume24h(parseFloat(ticker24hrData.volume) || 0)
        setPriceChange24h(parseFloat(ticker24hrData.priceChangePercent) || 0)
      }
      
      // Ïò§ÎçîÎ∂Å Îç∞Ïù¥ÌÑ∞
      const orderbookResponse = await fetch(`/api/binance/depth?symbol=${selectedCoin}&limit=100`)
      if (orderbookResponse.ok) {
        const orderbookData = await orderbookResponse.json()
        setOrderbook({
          bids: orderbookData.bids.map((bid: string[]) => ({
            price: parseFloat(bid[0]),
            amount: parseFloat(bid[1])
          })),
          asks: orderbookData.asks.map((ask: string[]) => ({
            price: parseFloat(ask[0]),
            amount: parseFloat(ask[1])
          })),
          lastUpdateId: orderbookData.lastUpdateId
        })
      }
      
      // ÏµúÍ∑º Í±∞Îûò Îç∞Ïù¥ÌÑ∞
      const tradesResponse = await fetch(`/api/binance/aggTrades?symbol=${selectedCoin}&limit=500`)
      if (tradesResponse.ok) {
        const tradesData = await tradesResponse.json()
        const formattedTrades = tradesData.map((trade: any) => ({
          price: parseFloat(trade.p),
          quantity: parseFloat(trade.q),
          time: trade.T,
          isBuyerMaker: trade.m,
          aggTradeId: trade.a
        }))
        setTrades(formattedTrades)
        tradesHistoryRef.current = formattedTrades
        
        // Ï¥àÍ∏∞ Ìå®ÌÑ¥ Î∂ÑÏÑù
        analyzeHFTPatterns(formattedTrades)
      }
      
    } catch (err) {
      console.error('Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏóêÎü¨:', err)
      setError(err instanceof Error ? err.message : 'Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®')
    } finally {
      setLoading(false)
    }
  }, [selectedCoin])
  
  // HFT Ìå®ÌÑ¥ Î∂ÑÏÑù Ìï®Ïàò
  const analyzeHFTPatterns = useCallback((trades: TradeData[]) => {
    if (trades.length < 10) return
    
    const newPatterns: HFTPattern[] = []
    const now = Date.now()
    
    // Í±∞Îûò ÎπàÎèÑ Î∂ÑÏÑù (1Ï¥à Îã®ÏúÑ)
    const tradeFrequency = trades.filter(t => now - t.time < 1000).length
    
    // ÏñëÎ∞©Ìñ• Í±∞Îûò ÎπÑÏú® (ÎßàÏºì Î©îÏù¥ÌÇπ ÌÉêÏßÄ)
    const buyTrades = trades.filter(t => !t.isBuyerMaker).length
    const sellTrades = trades.filter(t => t.isBuyerMaker).length
    const bidAskRatio = Math.min(buyTrades, sellTrades) / Math.max(buyTrades, sellTrades)
    
    // ÎßàÏºì Î©îÏù¥ÌÇπ Ìå®ÌÑ¥ ÌÉêÏßÄ
    if (bidAskRatio > 0.8 && tradeFrequency > 20) {
      newPatterns.push({
        timestamp: now,
        type: 'market_making',
        confidence: bidAskRatio * 100,
        volume: trades.reduce((sum, t) => sum + t.quantity, 0),
        price: trades[0].price,
        impact: tradeFrequency > 50 ? 'high' : tradeFrequency > 30 ? 'medium' : 'low'
      })
    }
    
    // Î™®Î©òÌÖÄ Ìå®ÌÑ¥ ÌÉêÏßÄ (ÏùºÎ∞©Ìñ• Í±∞Îûò)
    const recentTrades = trades.slice(0, 20)
    const buyRatio = recentTrades.filter(t => !t.isBuyerMaker).length / recentTrades.length
    
    if (buyRatio > 0.8 || buyRatio < 0.2) {
      newPatterns.push({
        timestamp: now,
        type: 'momentum',
        confidence: Math.abs(buyRatio - 0.5) * 200,
        volume: recentTrades.reduce((sum, t) => sum + t.quantity, 0),
        price: recentTrades[0].price,
        impact: Math.abs(buyRatio - 0.5) > 0.4 ? 'high' : 'medium'
      })
    }
    
    // Ïä§Ï∫òÌïë Ìå®ÌÑ¥ ÌÉêÏßÄ (Îπ†Î•∏ ÏßÑÏûÖ/Ï≤≠ÏÇ∞)
    const priceRange = Math.max(...trades.map(t => t.price)) - Math.min(...trades.map(t => t.price))
    const avgPrice = trades.reduce((sum, t) => sum + t.price, 0) / trades.length
    const priceVolatility = (priceRange / avgPrice) * 100
    
    if (tradeFrequency > 30 && priceVolatility < 0.1) {
      newPatterns.push({
        timestamp: now,
        type: 'scalping',
        confidence: Math.min(tradeFrequency / 50 * 100, 100),
        volume: trades.slice(0, 50).reduce((sum, t) => sum + t.quantity, 0),
        price: avgPrice,
        impact: tradeFrequency > 40 ? 'high' : 'medium'
      })
    }
    
    // Ï∞®ÏùµÍ±∞Îûò Ìå®ÌÑ¥ ÌÉêÏßÄ (ÎåÄÎüâ Í±∞Îûò)
    const largeTrades = trades.filter(t => t.quantity > trades.reduce((sum, t) => sum + t.quantity, 0) / trades.length * 3)
    
    if (largeTrades.length > 0) {
      newPatterns.push({
        timestamp: now,
        type: 'arbitrage',
        confidence: Math.min(largeTrades.length / 5 * 100, 100),
        volume: largeTrades.reduce((sum, t) => sum + t.quantity, 0),
        price: largeTrades[0].price,
        impact: largeTrades.length > 3 ? 'high' : 'medium'
      })
    }
    
    // Ìå®ÌÑ¥ ÏóÖÎç∞Ïù¥Ìä∏
    const updatedPatterns = [...newPatterns, ...patternsHistoryRef.current].slice(0, 100)
    setPatterns(updatedPatterns)
    patternsHistoryRef.current = updatedPatterns
  }, [])
  
  // WebSocket Ïó∞Í≤∞
  const connectWebSocket = useCallback(() => {
    // ÏßëÍ≥Ñ Í±∞Îûò Ïä§Ìä∏Î¶º
    const aggTradeUrl = `wss://stream.binance.com:9443/ws/${selectedCoin.toLowerCase()}@aggTrade`
    
    wsManager.current.connect(
      `aggTrade-${selectedCoin}`,
      aggTradeUrl,
      (data) => {
        if (data.e === 'aggTrade') {
          const newTrade: TradeData = {
            price: parseFloat(data.p),
            quantity: parseFloat(data.q),
            time: data.T,
            isBuyerMaker: data.m,
            aggTradeId: data.a
          }
          
          // Í±∞Îûò Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
          setTrades(prev => {
            const updated = [newTrade, ...prev].slice(0, 500)
            tradesHistoryRef.current = updated
            
            // Ïã§ÏãúÍ∞Ñ Ìå®ÌÑ¥ Î∂ÑÏÑù
            if (updated.length % 10 === 0) {
              analyzeHFTPatterns(updated.slice(0, 50))
            }
            
            return updated
          })
        }
      }
    )
    
    // Ìã∞Ïª§ Ïä§Ìä∏Î¶º
    const tickerUrl = `wss://stream.binance.com:9443/ws/${selectedCoin.toLowerCase()}@ticker`
    
    wsManager.current.connect(
      `ticker-${selectedCoin}`,
      tickerUrl,
      (data) => {
        if (data.e === '24hrTicker') {
          setCurrentPrice(parseFloat(data.c))
          setVolume24h(parseFloat(data.v))
          setPriceChange24h(parseFloat(data.P))
        }
      }
    )
    
    // Ïò§ÎçîÎ∂Å Ïä§Ìä∏Î¶º
    const depthUrl = `wss://stream.binance.com:9443/ws/${selectedCoin.toLowerCase()}@depth20@100ms`
    
    wsManager.current.connect(
      `depth-${selectedCoin}`,
      depthUrl,
      (data) => {
        if (data.e === 'depthUpdate') {
          setOrderbook({
            bids: data.b.map((bid: string[]) => ({
              price: parseFloat(bid[0]),
              amount: parseFloat(bid[1])
            })),
            asks: data.a.map((ask: string[]) => ({
              price: parseFloat(ask[0]),
              amount: parseFloat(ask[1])
            })),
            lastUpdateId: data.u
          })
        }
      }
    )
  }, [selectedCoin, analyzeHFTPatterns])
  
  // ÏΩîÏù∏ Î≥ÄÍ≤Ω Ï≤òÎ¶¨
  const handleCoinChange = useCallback((coin: string) => {
    // WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å
    wsManager.current.disconnect(`aggTrade-${selectedCoin}`)
    wsManager.current.disconnect(`ticker-${selectedCoin}`)
    wsManager.current.disconnect(`depth-${selectedCoin}`)
    
    // Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
    setTrades([])
    setPatterns([])
    setOrderbook(null)
    tradesHistoryRef.current = []
    patternsHistoryRef.current = []
    
    // ÏÉà ÏΩîÏù∏ ÏÑ§Ï†ï
    setSelectedCoin(coin)
  }, [selectedCoin])

  // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Î∞è WebSocket Ïó∞Í≤∞
  useEffect(() => {
    loadInitialData()
    connectWebSocket()
    
    return () => {
      wsManager.current.disconnect(`aggTrade-${selectedCoin}`)
      wsManager.current.disconnect(`ticker-${selectedCoin}`)
      wsManager.current.disconnect(`depth-${selectedCoin}`)
    }
  }, [selectedCoin, loadInitialData, connectWebSocket])

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-black to-gray-900">
      {/* Ìó§Îçî */}
      <div className="sticky top-0 z-50 bg-black/90 backdrop-blur-sm border-b border-gray-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div>
              <h1 className="text-2xl sm:text-3xl font-bold text-white">ü§ñ HFT Ìå®ÌÑ¥ Î∂ÑÏÑù</h1>
              <p className="text-gray-400 text-sm mt-1">Í≥†ÎπàÎèÑ Í±∞Îûò Ìå®ÌÑ¥ Ïã§ÏãúÍ∞Ñ ÌÉêÏßÄ ÏãúÏä§ÌÖú</p>
            </div>
            
            {/* ÏΩîÏù∏ ÏÑ†ÌÉùÍ∏∞ */}
            <CoinSelector
              coins={SUPPORTED_COINS}
              selected={selectedCoin}
              onChange={handleCoinChange}
              currentPrice={currentPrice}
              priceChange24h={priceChange24h}
            />
          </div>
          
          {/* Ïã§ÏãúÍ∞Ñ ÏßÄÌëú */}
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-4 mt-4">
            <div className="bg-gray-800/50 rounded-lg p-3">
              <p className="text-gray-400 text-xs">ÌòÑÏû¨Í∞Ä</p>
              <p className="text-white font-bold text-lg">
                ${currentPrice.toLocaleString()}
              </p>
            </div>
            <div className="bg-gray-800/50 rounded-lg p-3">
              <p className="text-gray-400 text-xs">24ÏãúÍ∞Ñ Î≥ÄÎèô</p>
              <p className={`font-bold text-lg ${priceChange24h >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {priceChange24h >= 0 ? '+' : ''}{safePrice(priceChange24h, 2)}%
              </p>
            </div>
            <div className="bg-gray-800/50 rounded-lg p-3">
              <p className="text-gray-400 text-xs">24ÏãúÍ∞Ñ Í±∞ÎûòÎüâ</p>
              <p className="text-white font-bold text-lg">
                {(volume24h / 1000000).toFixed(2)}M
              </p>
            </div>
            <div className="bg-gray-800/50 rounded-lg p-3">
              <p className="text-gray-400 text-xs">Í∞êÏßÄÎêú Ìå®ÌÑ¥</p>
              <p className="text-purple-400 font-bold text-lg">
                {patterns.length}Í∞ú
              </p>
            </div>
          </div>
        </div>
      </div>
      
      {/* Î©îÏù∏ ÏΩòÌÖêÏ∏† */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {loading ? (
          <div className="flex items-center justify-center h-64">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500"></div>
          </div>
        ) : error ? (
          <div className="bg-red-500/10 border border-red-500/30 rounded-xl p-6">
            <p className="text-red-400">ÏóêÎü¨: {error}</p>
          </div>
        ) : (
          <div className="space-y-8">
            {/* Í∞úÎÖê Í∞ÄÏù¥Îìú */}
            <ConceptGuide />
            
            {/* ÏïåÍ≥†Î¶¨Ï¶ò ÌôúÎèô ÌûàÌä∏Îßµ */}
            <AlgoActivityHeatmap
              trades={trades}
              patterns={patterns}
              selectedCoin={selectedCoin}
            />
            
            {/* Ìå®ÌÑ¥ Î∂ÑÎ•òÍ∏∞ */}
            <PatternClassifier
              patterns={patterns}
              trades={trades}
            />
            
            {/* Î¥á ÌñâÎèô Î∂ÑÏÑù */}
            <BotBehaviorAnalysis
              patterns={patterns}
              trades={trades}
              orderbook={orderbook}
            />
            
            {/* Ï†ÑÎûµ Ï∂îÎ°† ÎèÑÍµ¨ */}
            <StrategyInference
              patterns={patterns}
              trades={trades}
              currentPrice={currentPrice}
            />
            
            {/* ÏãúÏû• Ï°∞Ïûë ÌÉêÏßÄ */}
            <MarketManipulationDetector
              trades={trades}
              orderbook={orderbook}
              patterns={patterns}
            />
            
            {/* Í±∞ÎûòÎüâ ÌîÑÎ°úÌååÏùº */}
            <VolumeProfile
              trades={trades}
              currentPrice={currentPrice}
            />
            
            {/* Ìä∏Î†àÏù¥Îî© Ï†ÑÎûµ */}
            <TradingStrategy
              patterns={patterns}
              currentPrice={currentPrice}
              priceChange24h={priceChange24h}
              volume24h={volume24h}
            />
            
            {/* ÏÑ±Îä• ÏßÄÌëú */}
            <PerformanceMetrics
              patterns={patterns}
              trades={trades}
            />
          </div>
        )}
      </div>
      
    </div>
  )
}