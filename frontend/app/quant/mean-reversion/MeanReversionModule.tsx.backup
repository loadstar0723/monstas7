'use client'

import { useState, useEffect, useRef } from 'react'
import dynamic from 'next/dynamic'

// ì»´í¬ë„ŒíŠ¸ ë™ì  ì„í¬íŠ¸ (ì„±ëŠ¥ ìµœì í™”)
const CoinSelector = dynamic(() => import('./components/CoinSelector'), {
  loading: () => <div className="animate-pulse h-16 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const ConceptSection = dynamic(() => import('./components/ConceptSection'), {
  loading: () => <div className="animate-pulse h-48 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RealtimeAnalysis = dynamic(() => import('./components/RealtimeAnalysis'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const PriceChart = dynamic(() => import('./components/PriceChart'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const BollingerBands = dynamic(() => import('./components/BollingerBands'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const ZScoreAnalysis = dynamic(() => import('./components/ZScoreAnalysis'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RSIDivergence = dynamic(() => import('./components/RSIDivergence'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const TradingSignals = dynamic(() => import('./components/TradingSignals'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const BacktestResults = dynamic(() => import('./components/BacktestResults'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RiskManagement = dynamic(() => import('./components/RiskManagement'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const StrategyGuide = dynamic(() => import('./components/StrategyGuide'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const AIRecommendation = dynamic(() => import('./components/AIRecommendation'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

// 10ê°œ ì£¼ìš” ì½”ì¸ ì •ë³´
export const COINS = [
  { symbol: 'BTCUSDT', name: 'Bitcoin', icon: 'â‚¿', color: '#F7931A', initialPrice: 98000 },
  { symbol: 'ETHUSDT', name: 'Ethereum', icon: 'Î', color: '#627EEA', initialPrice: 3500 },
  { symbol: 'BNBUSDT', name: 'BNB', icon: 'ğŸ”¸', color: '#F3BA2F', initialPrice: 700 },
  { symbol: 'SOLUSDT', name: 'Solana', icon: 'â—', color: '#14F195', initialPrice: 240 },
  { symbol: 'XRPUSDT', name: 'XRP', icon: 'âœ•', color: '#23292F', initialPrice: 2.5 },
  { symbol: 'ADAUSDT', name: 'Cardano', icon: 'â‚³', color: '#0033AD', initialPrice: 1.0 },
  { symbol: 'DOGEUSDT', name: 'Dogecoin', icon: 'Ã', color: '#C2A633', initialPrice: 0.4 },
  { symbol: 'AVAXUSDT', name: 'Avalanche', icon: 'ğŸ”º', color: '#E84142', initialPrice: 45 },
  { symbol: 'MATICUSDT', name: 'Polygon', icon: 'â¬Ÿ', color: '#8247E5', initialPrice: 1.5 },
  { symbol: 'DOTUSDT', name: 'Polkadot', icon: 'âšª', color: '#E6007A', initialPrice: 10 }
]

interface MarketData {
  price: number
  change24h: number
  volume24h: number
  high24h: number
  low24h: number
  sma20: number
  sma50: number
  sma200: number
  upperBand: number
  lowerBand: number
  zScore: number
  rsi: number
}

export default function MeanReversionModule() {
  const [selectedCoin, setSelectedCoin] = useState(COINS[0])
  const [marketData, setMarketData] = useState<MarketData | null>(null)
  const [historicalData, setHistoricalData] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const wsRef = useRef<WebSocket | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // WebSocket ì—°ê²° ê´€ë¦¬ (try-catch ê°•í™”)
  const connectWebSocket = (symbol: string) => {
    try {
      // ê¸°ì¡´ ì—°ê²° ì•ˆì „í•˜ê²Œ ì •ë¦¬
      if (wsRef.current) {
        try {
          wsRef.current.onclose = null
          wsRef.current.onerror = null
          wsRef.current.onmessage = null
          wsRef.current.close(1000, 'Switching connection')
        } catch (closeError) {
          console.warn('Error closing previous WebSocket:', closeError)
        }
        wsRef.current = null
      }

      // ì¬ì—°ê²° íƒ€ì´ë¨¸ ì •ë¦¬
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }

      const wsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker`
      
      let ws: WebSocket
      try {
        ws = new WebSocket(wsUrl)
      } catch (wsCreateError) {
        console.error('WebSocket ìƒì„± ì‹¤íŒ¨:', wsCreateError)
        // 3ì´ˆ í›„ ì¬ì‹œë„
        reconnectTimeoutRef.current = setTimeout(() => {
          connectWebSocket(symbol)
        }, 3000)
        return
      }

      wsRef.current = ws

      ws.onopen = () => {
        console.log(`WebSocket ì—°ê²° ì„±ê³µ: ${symbol}`)
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          
          // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
          if (!data || !data.s || data.s !== symbol) {
            console.warn('Invalid or mismatched WebSocket data:', data)
            return
          }
          
          setMarketData(prev => ({
            price: parseFloat(data.c) || prev?.price || 0,
            change24h: parseFloat(data.P) || prev?.change24h || 0,
            volume24h: parseFloat(data.v) || prev?.volume24h || 0,
            high24h: parseFloat(data.h) || prev?.high24h || 0,
            low24h: parseFloat(data.l) || prev?.low24h || 0,
            sma20: prev?.sma20 || parseFloat(data.c) || 0,
            sma50: prev?.sma50 || parseFloat(data.c) || 0,
            sma200: prev?.sma200 || parseFloat(data.c) || 0,
            upperBand: prev?.upperBand || (parseFloat(data.c) * 1.02) || 0,
            lowerBand: prev?.lowerBand || (parseFloat(data.c) * 0.98) || 0,
            zScore: prev?.zScore || 0,
            rsi: prev?.rsi || 50
          }))
        } catch (parseError) {
          console.error('ë°ì´í„° íŒŒì‹± ì—ëŸ¬:', parseError)
        }
      }

      ws.onerror = (event) => {
        console.error('WebSocket ì—°ê²° ì—ëŸ¬:', event)
        // ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
        const coin = COINS.find(c => c.symbol === symbol)
        if (coin) {
          setMarketData({
            price: coin.initialPrice,
            change24h: 0,
            volume24h: 0,
            high24h: coin.initialPrice * 1.05,
            low24h: coin.initialPrice * 0.95,
            sma20: coin.initialPrice,
            sma50: coin.initialPrice,
            sma200: coin.initialPrice,
            upperBand: coin.initialPrice * 1.02,
            lowerBand: coin.initialPrice * 0.98,
            zScore: 0,
            rsi: 50
          })
        }
      }

      ws.onclose = (event) => {
        console.log(`WebSocket ì—°ê²° ì¢…ë£Œ (ì½”ë“œ: ${event.code})`)
        wsRef.current = null
        
        // ì •ìƒ ì¢…ë£Œê°€ ì•„ë‹Œ ê²½ìš° ì¬ì—°ê²°
        if (event.code !== 1000 && event.code !== 1001) {
          if (reconnectTimeoutRef.current) {
            clearTimeout(reconnectTimeoutRef.current)
          }
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log('WebSocket ì¬ì—°ê²° ì‹œë„...')
            connectWebSocket(symbol)
          }, 3000)
        }
      }
    } catch (error) {
      console.error('WebSocket ì„¤ì • ì—ëŸ¬:', error)
      
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
      const coin = COINS.find(c => c.symbol === symbol)
      if (coin) {
        setMarketData({
          price: coin.initialPrice,
          change24h: 0,
          volume24h: 0,
          high24h: coin.initialPrice * 1.05,
          low24h: coin.initialPrice * 0.95,
          sma20: coin.initialPrice,
          sma50: coin.initialPrice,
          sma200: coin.initialPrice,
          upperBand: coin.initialPrice * 1.02,
          lowerBand: coin.initialPrice * 0.98,
          zScore: 0,
          rsi: 50
        })
      }
      
      // 3ì´ˆ í›„ ì¬ì‹œë„
      reconnectTimeoutRef.current = setTimeout(() => {
        connectWebSocket(symbol)
      }, 3000)
    }
  }

  // ê³¼ê±° ë°ì´í„° ë¡œë“œ (try-catch ê°•í™”)
  const loadHistoricalData = async (symbol: string) => {
    try {
      const response = await fetch(
        `/api/binance/klines?symbol=${symbol}&interval=1d&limit=200`,
        {
          timeout: 15000,
          signal: AbortSignal.timeout(15000)
        }
      )
      
      // response.ok ì²´í¬ ê°•í™”
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached for historical data:', symbol)
          throw new Error('ìš”ì²­ ë¹ˆë„ ì´ˆê³¼ - ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”')
        }
        if (response.status === 404) {
          throw new Error(`ì‹¬ë³¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${symbol}`)
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const result = await response.json()
      
      // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ê°•í™”
      const data = result.data || result.klines || result
      
      if (!Array.isArray(data)) {
        throw new Error('Invalid data format - expected array')
      }
      
      if (data.length === 0) {
        throw new Error('Empty historical data received')
      }
      
      setHistoricalData(data)
      
      // ì´ë™í‰ê·  ê³„ì‚° (ê°•í™”ëœ ì—ëŸ¬ ì²˜ë¦¬)
      if (data.length >= 20) { // 200ì—ì„œ 20ìœ¼ë¡œ ì™„í™”
        try {
          // ê°€ê²© ë°ì´í„° ì¶”ì¶œ ë° ìœ íš¨ì„± ê²€ì‚¬
          const prices = data
            .map((d: any) => {
              const price = parseFloat(Array.isArray(d) ? d[4] : d.close)
              return isFinite(price) && price > 0 ? price : null
            })
            .filter((p: number | null) => p !== null) as number[]
          
          // ê¸°ë³¸ ê°’ ê°•í™” ê²€ì¦
          if (prices.length < 10) {
            throw new Error(`Insufficient valid price data: ${prices.length} valid prices`)
          }
          
          // ì•ˆì „í•œ ì´ë™í‰ê·  ê³„ì‚°
          const calculateSafeSMA = (arr: number[], period: number): number => {
            if (arr.length < period) return arr[arr.length - 1] || 0
            const sum = arr.slice(-period).reduce((a, b) => a + b, 0)
            return sum / period
          }
          
          const sma20 = calculateSafeSMA(prices, 20)
          const sma50 = calculateSafeSMA(prices, 50)
          const sma200 = calculateSafeSMA(prices, 200)
          
          // ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚° (ê°•í™”ëœ ë²„ì „)
          const recentPrices = prices.slice(-Math.min(20, prices.length))
          let stdDev = 0
          if (recentPrices.length >= 2 && sma20 > 0) {
            const variance = recentPrices.reduce((sum: number, price: number) => {
              return sum + Math.pow(price - sma20, 2)
            }, 0) / recentPrices.length
            stdDev = Math.sqrt(variance)
          }
          
          // Z-Score ê³„ì‚° (ì•ˆì „í•˜ê²Œ)
          const currentPrice = prices[prices.length - 1] || 0
          let zScore = 0
          if (stdDev > 0 && sma20 > 0) {
            zScore = (currentPrice - sma20) / stdDev
            // Z-Score ë²”ìœ„ ì œí•œ (-10 ~ +10)
            zScore = Math.max(-10, Math.min(10, zScore))
          }
          
          // RSI ê³„ì‚° (ê°•í™”ëœ ë²„ì „)
          let gains = 0, losses = 0, validChanges = 0
          const rsiPeriod = Math.min(14, prices.length - 1)
          
          if (rsiPeriod > 0) {
            for (let i = Math.max(1, prices.length - rsiPeriod); i < prices.length; i++) {
              const prevPrice = prices[i - 1]
              const currentPrice = prices[i]
              
              if (prevPrice > 0 && currentPrice > 0) {
                const change = currentPrice - prevPrice
                if (change > 0) {
                  gains += change
                } else if (change < 0) {
                  losses += Math.abs(change)
                }
                validChanges++
              }
            }
          }
          
          let rsi = 50 // ê¸°ë³¸ê°’
          if (validChanges > 0) {
            const avgGain = gains / validChanges
            const avgLoss = losses / validChanges
            
            if (avgLoss === 0) {
              rsi = gains > 0 ? 100 : 50
            } else {
              const rs = avgGain / avgLoss
              rsi = 100 - (100 / (1 + rs))
            }
            
            // RSI ë²”ìœ„ í™•ì¸ (0-100)
            rsi = Math.max(0, Math.min(100, rsi))
          }
          
          // 24ì‹œê°„ ìµœê³ /ìµœì €ê°€ ê³„ì‚° (ê°•í™”ëœ ë²„ì „)
          const recent24h = data.slice(-Math.min(24, data.length))
          const validHighs = recent24h
            .map((d: any) => parseFloat(Array.isArray(d) ? d[2] : d.high))
            .filter((h: number) => isFinite(h) && h > 0)
          const validLows = recent24h
            .map((d: any) => parseFloat(Array.isArray(d) ? d[3] : d.low))
            .filter((l: number) => isFinite(l) && l > 0)
            
          const high24h = validHighs.length > 0 ? Math.max(...validHighs) : currentPrice * 1.05
          const low24h = validLows.length > 0 ? Math.min(...validLows) : currentPrice * 0.95
          
          setMarketData(prev => ({
            ...prev!,
            sma20: sma20 || prev?.sma20 || 0,
            sma50: sma50 || prev?.sma50 || 0,
            sma200: sma200 || prev?.sma200 || 0,
            upperBand: (sma20 + (stdDev * 2)) || prev?.upperBand || 0,
            lowerBand: (sma20 - (stdDev * 2)) || prev?.lowerBand || 0,
            zScore: isFinite(zScore) ? zScore : 0,
            rsi: isFinite(rsi) && rsi >= 0 && rsi <= 100 ? rsi : 50,
            high24h: high24h || prev?.high24h || 0,
            low24h: low24h || prev?.low24h || 0
          }))
        } catch (calcError) {
          console.error('ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜:', calcError)
          // ê³„ì‚° ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
          const coin = COINS.find(c => c.symbol === symbol)
          if (coin && prev) {
            setMarketData(prev => ({
              ...prev!,
              sma20: prev?.price || coin.initialPrice,
              sma50: prev?.price || coin.initialPrice,
              sma200: prev?.price || coin.initialPrice,
              upperBand: (prev?.price || coin.initialPrice) * 1.02,
              lowerBand: (prev?.price || coin.initialPrice) * 0.98,
              zScore: 0,
              rsi: 50,
              high24h: (prev?.price || coin.initialPrice) * 1.05,
              low24h: (prev?.price || coin.initialPrice) * 0.95
            }))
          }
        }
      }
    } catch (error: any) {
      console.error('ê³¼ê±° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error)
      
      // ì—ëŸ¬ ì‹œ ë¹ˆ ë°°ì—´ ì„¤ì •
      setHistoricalData([])
      
      // ì—ëŸ¬ íƒ€ì…ì— ë”°ë¥¸ ì²˜ë¦¬
      if (error.name === 'AbortError') {
        console.log('ìš”ì²­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤:', symbol)
      } else {
        // ê¸°ë³¸ ë°ì´í„°ë¡œ í´ë°±
        const coin = COINS.find(c => c.symbol === symbol)
        if (coin) {
          setMarketData(prev => prev ? {
            ...prev,
            sma20: coin.initialPrice,
            sma50: coin.initialPrice,
            sma200: coin.initialPrice,
            upperBand: coin.initialPrice * 1.02,
            lowerBand: coin.initialPrice * 0.98,
            zScore: 0,
            rsi: 50
          } : null)
        }
      }
    } finally {
      setLoading(false)
    }
  }

  // ì½”ì¸ ë³€ê²½ ì‹œ
  useEffect(() => {
    setLoading(true)
    setMarketData({
      price: selectedCoin.initialPrice,
      change24h: 0,
      volume24h: 0,
      high24h: selectedCoin.initialPrice * 1.05,
      low24h: selectedCoin.initialPrice * 0.95,
      sma20: selectedCoin.initialPrice,
      sma50: selectedCoin.initialPrice,
      sma200: selectedCoin.initialPrice,
      upperBand: selectedCoin.initialPrice * 1.02,
      lowerBand: selectedCoin.initialPrice * 0.98,
      zScore: 0,
      rsi: 50
    })
    
    connectWebSocket(selectedCoin.symbol)
    loadHistoricalData(selectedCoin.symbol)

    return () => {
      // ì •ë¦¬ ì‹œ ì¬ì—°ê²° ë°©ì§€
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }
      
      if (wsRef.current) {
        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°ë¡œ ì¬ì—°ê²° ë°©ì§€
        wsRef.current.onclose = null
        wsRef.current.onerror = null
        wsRef.current.onmessage = null
        wsRef.current.onopen = null
        
        // ì •ìƒ ì¢…ë£Œ ì½”ë“œë¡œ ë‹«ê¸°
        if (wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.close(1000, 'Component unmounting')
        }
        wsRef.current = null
      }
    }
  }, [selectedCoin])

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-black to-gray-900">
      {/* í—¤ë” */}
      <div className="border-b border-gray-800 sticky top-0 bg-black/90 backdrop-blur-sm z-40">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <h1 className="text-2xl md:text-3xl font-bold text-white">
            í‰ê· íšŒê·€ ì „ë¬¸ ë¶„ì„
          </h1>
          <p className="text-gray-400 text-sm md:text-base mt-1">
            Mean Reversion Strategy - ê°€ê²©ì€ ê²°êµ­ í‰ê· ìœ¼ë¡œ ëŒì•„ì˜¨ë‹¤
          </p>
        </div>
      </div>

      {/* ì½”ì¸ ì„ íƒ */}
      <div className="sticky top-[73px] bg-black/90 backdrop-blur-sm z-30 border-b border-gray-800">
        <CoinSelector 
          coins={COINS}
          selectedCoin={selectedCoin}
          onSelectCoin={setSelectedCoin}
        />
      </div>

      {/* ë©”ì¸ ì½˜í…ì¸  */}
      <div className="max-w-7xl mx-auto px-4 py-6 space-y-6">
        {/* ê°œë… ì„¤ëª… ì„¹ì…˜ */}
        <ConceptSection coinName={selectedCoin.name} />

        {/* ì‹¤ì‹œê°„ ë¶„ì„ */}
        <RealtimeAnalysis 
          coin={selectedCoin}
          marketData={marketData}
          loading={loading}
        />

        {/* ì°¨íŠ¸ ì„¹ì…˜ */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <PriceChart 
            coin={selectedCoin}
            historicalData={historicalData}
            marketData={marketData}
          />
          <BollingerBands 
            coin={selectedCoin}
            historicalData={historicalData}
            marketData={marketData}
          />
        </div>

        {/* ì§€í‘œ ë¶„ì„ */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <ZScoreAnalysis 
            coin={selectedCoin}
            marketData={marketData}
            historicalData={historicalData}
          />
          <RSIDivergence 
            coin={selectedCoin}
            marketData={marketData}
            historicalData={historicalData}
          />
        </div>

        {/* íŠ¸ë ˆì´ë”© ì‹œê·¸ë„ */}
        <TradingSignals 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ */}
        <BacktestResults 
          coin={selectedCoin}
          historicalData={historicalData}
        />

        {/* ë¦¬ìŠ¤í¬ ê´€ë¦¬ */}
        <RiskManagement 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* ì „ëµ ê°€ì´ë“œ */}
        <StrategyGuide 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* AI ì¶”ì²œ */}
        <AIRecommendation 
          coin={selectedCoin}
          marketData={marketData}
        />
      </div>
    </div>
  )
}