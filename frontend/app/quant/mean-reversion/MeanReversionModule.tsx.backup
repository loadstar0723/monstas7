'use client'

import { useState, useEffect, useRef } from 'react'
import dynamic from 'next/dynamic'

// Ïª¥Ìè¨ÎÑåÌä∏ ÎèôÏ†Å ÏûÑÌè¨Ìä∏ (ÏÑ±Îä• ÏµúÏ†ÅÌôî)
const CoinSelector = dynamic(() => import('./components/CoinSelector'), {
  loading: () => <div className="animate-pulse h-16 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const ConceptSection = dynamic(() => import('./components/ConceptSection'), {
  loading: () => <div className="animate-pulse h-48 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RealtimeAnalysis = dynamic(() => import('./components/RealtimeAnalysis'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const PriceChart = dynamic(() => import('./components/PriceChart'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const BollingerBands = dynamic(() => import('./components/BollingerBands'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const ZScoreAnalysis = dynamic(() => import('./components/ZScoreAnalysis'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RSIDivergence = dynamic(() => import('./components/RSIDivergence'), {
  loading: () => <div className="animate-pulse h-80 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const TradingSignals = dynamic(() => import('./components/TradingSignals'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const BacktestResults = dynamic(() => import('./components/BacktestResults'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const RiskManagement = dynamic(() => import('./components/RiskManagement'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const StrategyGuide = dynamic(() => import('./components/StrategyGuide'), {
  loading: () => <div className="animate-pulse h-96 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

const AIRecommendation = dynamic(() => import('./components/AIRecommendation'), {
  loading: () => <div className="animate-pulse h-64 bg-gray-800/50 rounded-lg" />,
  ssr: false
})

// 10Í∞ú Ï£ºÏöî ÏΩîÏù∏ Ï†ïÎ≥¥
export const COINS = [
  { symbol: 'BTCUSDT', name: 'Bitcoin', icon: '‚Çø', color: '#F7931A', initialPrice: 98000 },
  { symbol: 'ETHUSDT', name: 'Ethereum', icon: 'Œû', color: '#627EEA', initialPrice: 3500 },
  { symbol: 'BNBUSDT', name: 'BNB', icon: 'üî∏', color: '#F3BA2F', initialPrice: 700 },
  { symbol: 'SOLUSDT', name: 'Solana', icon: '‚óé', color: '#14F195', initialPrice: 240 },
  { symbol: 'XRPUSDT', name: 'XRP', icon: '‚úï', color: '#23292F', initialPrice: 2.5 },
  { symbol: 'ADAUSDT', name: 'Cardano', icon: '‚Ç≥', color: '#0033AD', initialPrice: 1.0 },
  { symbol: 'DOGEUSDT', name: 'Dogecoin', icon: '√ê', color: '#C2A633', initialPrice: 0.4 },
  { symbol: 'AVAXUSDT', name: 'Avalanche', icon: 'üî∫', color: '#E84142', initialPrice: 45 },
  { symbol: 'MATICUSDT', name: 'Polygon', icon: '‚¨ü', color: '#8247E5', initialPrice: 1.5 },
  { symbol: 'DOTUSDT', name: 'Polkadot', icon: '‚ö™', color: '#E6007A', initialPrice: 10 }
]

interface MarketData {
  price: number
  change24h: number
  volume24h: number
  high24h: number
  low24h: number
  sma20: number
  sma50: number
  sma200: number
  upperBand: number
  lowerBand: number
  zScore: number
  rsi: number
}

export default function MeanReversionModule() {
  const [selectedCoin, setSelectedCoin] = useState(COINS[0])
  const [marketData, setMarketData] = useState<MarketData | null>(null)
  const [historicalData, setHistoricalData] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const wsRef = useRef<WebSocket | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // WebSocket Ïó∞Í≤∞ Í¥ÄÎ¶¨ (try-catch Í∞ïÌôî)
  const connectWebSocket = (symbol: string) => {
    try {
      // Í∏∞Ï°¥ Ïó∞Í≤∞ ÏïàÏ†ÑÌïòÍ≤å Ï†ïÎ¶¨
      if (wsRef.current) {
        try {
          wsRef.current.onclose = null
          wsRef.current.onerror = null
          wsRef.current.onmessage = null
          wsRef.current.close(1000, 'Switching connection')
        } catch (closeError) {
          console.warn('Error closing previous WebSocket:', closeError)
        }
        wsRef.current = null
      }

      // Ïû¨Ïó∞Í≤∞ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }

      const wsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@ticker`
      
      let ws: WebSocket
      try {
        ws = new WebSocket(wsUrl)
      } catch (wsCreateError) {
        console.error('WebSocket ÏÉùÏÑ± Ïã§Ìå®:', wsCreateError)
        // 3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ
        reconnectTimeoutRef.current = setTimeout(() => {
          connectWebSocket(symbol)
        }, 3000)
        return
      }

      wsRef.current = ws

      ws.onopen = () => {
        console.log(`WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ: ${symbol}`)
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          
          // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          if (!data || !data.s || data.s !== symbol) {
            console.warn('Invalid or mismatched WebSocket data:', data)
            return
          }
          
          setMarketData(prev => ({
            price: parseFloat(data.c) || prev?.price || 0,
            change24h: parseFloat(data.P) || prev?.change24h || 0,
            volume24h: parseFloat(data.v) || prev?.volume24h || 0,
            high24h: parseFloat(data.h) || prev?.high24h || 0,
            low24h: parseFloat(data.l) || prev?.low24h || 0,
            sma20: prev?.sma20 || parseFloat(data.c) || 0,
            sma50: prev?.sma50 || parseFloat(data.c) || 0,
            sma200: prev?.sma200 || parseFloat(data.c) || 0,
            upperBand: prev?.upperBand || (parseFloat(data.c) * 1.02) || 0,
            lowerBand: prev?.lowerBand || (parseFloat(data.c) * 0.98) || 0,
            zScore: prev?.zScore || 0,
            rsi: prev?.rsi || 50
          }))
        } catch (parseError) {
          console.error('Îç∞Ïù¥ÌÑ∞ ÌååÏã± ÏóêÎü¨:', parseError)
        }
      }

      ws.onerror = (event) => {
        console.error('WebSocket Ïó∞Í≤∞ ÏóêÎü¨:', event)
        // ÏóêÎü¨ Ïãú Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
        const coin = COINS.find(c => c.symbol === symbol)
        if (coin) {
          setMarketData({
            price: coin.initialPrice,
            change24h: 0,
            volume24h: 0,
            high24h: coin.initialPrice * 1.05,
            low24h: coin.initialPrice * 0.95,
            sma20: coin.initialPrice,
            sma50: coin.initialPrice,
            sma200: coin.initialPrice,
            upperBand: coin.initialPrice * 1.02,
            lowerBand: coin.initialPrice * 0.98,
            zScore: 0,
            rsi: 50
          })
        }
      }

      ws.onclose = (event) => {
        console.log(`WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å (ÏΩîÎìú: ${event.code})`)
        wsRef.current = null
        
        // Ï†ïÏÉÅ Ï¢ÖÎ£åÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ Ïû¨Ïó∞Í≤∞
        if (event.code !== 1000 && event.code !== 1001) {
          if (reconnectTimeoutRef.current) {
            clearTimeout(reconnectTimeoutRef.current)
          }
          reconnectTimeoutRef.current = setTimeout(() => {
            console.log('WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ...')
            connectWebSocket(symbol)
          }, 3000)
        }
      }
    } catch (error) {
      console.error('WebSocket ÏÑ§Ï†ï ÏóêÎü¨:', error)
      
      // ÏóêÎü¨ Ïãú Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
      const coin = COINS.find(c => c.symbol === symbol)
      if (coin) {
        setMarketData({
          price: coin.initialPrice,
          change24h: 0,
          volume24h: 0,
          high24h: coin.initialPrice * 1.05,
          low24h: coin.initialPrice * 0.95,
          sma20: coin.initialPrice,
          sma50: coin.initialPrice,
          sma200: coin.initialPrice,
          upperBand: coin.initialPrice * 1.02,
          lowerBand: coin.initialPrice * 0.98,
          zScore: 0,
          rsi: 50
        })
      }
      
      // 3Ï¥à ÌõÑ Ïû¨ÏãúÎèÑ
      reconnectTimeoutRef.current = setTimeout(() => {
        connectWebSocket(symbol)
      }, 3000)
    }
  }

  // Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú (try-catch Í∞ïÌôî)
  const loadHistoricalData = async (symbol: string) => {
    try {
      const response = await fetch(
        `/api/binance/klines?symbol=${symbol}&interval=1d&limit=200`,
        {
          timeout: 15000,
          signal: AbortSignal.timeout(15000)
        }
      )
      
      // response.ok Ï≤¥ÌÅ¨ Í∞ïÌôî
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached for historical data:', symbol)
          throw new Error('ÏöîÏ≤≠ ÎπàÎèÑ Ï¥àÍ≥º - Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî')
        }
        if (response.status === 404) {
          throw new Error(`Ïã¨Î≥ºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${symbol}`)
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const result = await response.json()
      
      // Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Í∞ïÌôî
      const data = result.data || result.klines || result
      
      if (!Array.isArray(data)) {
        throw new Error('Invalid data format - expected array')
      }
      
      if (data.length === 0) {
        throw new Error('Empty historical data received')
      }
      
      setHistoricalData(data)
      
      // Ïù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞ (Í∞ïÌôîÎêú ÏóêÎü¨ Ï≤òÎ¶¨)
      if (data.length >= 20) { // 200ÏóêÏÑú 20ÏúºÎ°ú ÏôÑÌôî
        try {
          // Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Î∞è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
          const prices = data
            .map((d: any) => {
              const price = parseFloat(Array.isArray(d) ? d[4] : d.close)
              return isFinite(price) && price > 0 ? price : null
            })
            .filter((p: number | null) => p !== null) as number[]
          
          // Í∏∞Î≥∏ Í∞í Í∞ïÌôî Í≤ÄÏ¶ù
          if (prices.length < 10) {
            throw new Error(`Insufficient valid price data: ${prices.length} valid prices`)
          }
          
          // ÏïàÏ†ÑÌïú Ïù¥ÎèôÌèâÍ∑† Í≥ÑÏÇ∞
          const calculateSafeSMA = (arr: number[], period: number): number => {
            if (arr.length < period) return arr[arr.length - 1] || 0
            const sum = arr.slice(-period).reduce((a, b) => a + b, 0)
            return sum / period
          }
          
          const sma20 = calculateSafeSMA(prices, 20)
          const sma50 = calculateSafeSMA(prices, 50)
          const sma200 = calculateSafeSMA(prices, 200)
          
          // Î≥ºÎ¶∞Ï†Ä Î∞¥Îìú Í≥ÑÏÇ∞ (Í∞ïÌôîÎêú Î≤ÑÏ†Ñ)
          const recentPrices = prices.slice(-Math.min(20, prices.length))
          let stdDev = 0
          if (recentPrices.length >= 2 && sma20 > 0) {
            const variance = recentPrices.reduce((sum: number, price: number) => {
              return sum + Math.pow(price - sma20, 2)
            }, 0) / recentPrices.length
            stdDev = Math.sqrt(variance)
          }
          
          // Z-Score Í≥ÑÏÇ∞ (ÏïàÏ†ÑÌïòÍ≤å)
          const currentPrice = prices[prices.length - 1] || 0
          let zScore = 0
          if (stdDev > 0 && sma20 > 0) {
            zScore = (currentPrice - sma20) / stdDev
            // Z-Score Î≤îÏúÑ Ï†úÌïú (-10 ~ +10)
            zScore = Math.max(-10, Math.min(10, zScore))
          }
          
          // RSI Í≥ÑÏÇ∞ (Í∞ïÌôîÎêú Î≤ÑÏ†Ñ)
          let gains = 0, losses = 0, validChanges = 0
          const rsiPeriod = Math.min(14, prices.length - 1)
          
          if (rsiPeriod > 0) {
            for (let i = Math.max(1, prices.length - rsiPeriod); i < prices.length; i++) {
              const prevPrice = prices[i - 1]
              const currentPrice = prices[i]
              
              if (prevPrice > 0 && currentPrice > 0) {
                const change = currentPrice - prevPrice
                if (change > 0) {
                  gains += change
                } else if (change < 0) {
                  losses += Math.abs(change)
                }
                validChanges++
              }
            }
          }
          
          let rsi = 50 // Í∏∞Î≥∏Í∞í
          if (validChanges > 0) {
            const avgGain = gains / validChanges
            const avgLoss = losses / validChanges
            
            if (avgLoss === 0) {
              rsi = gains > 0 ? 100 : 50
            } else {
              const rs = avgGain / avgLoss
              rsi = 100 - (100 / (1 + rs))
            }
            
            // RSI Î≤îÏúÑ ÌôïÏù∏ (0-100)
            rsi = Math.max(0, Math.min(100, rsi))
          }
          
          // 24ÏãúÍ∞Ñ ÏµúÍ≥†/ÏµúÏ†ÄÍ∞Ä Í≥ÑÏÇ∞ (Í∞ïÌôîÎêú Î≤ÑÏ†Ñ)
          const recent24h = data.slice(-Math.min(24, data.length))
          const validHighs = recent24h
            .map((d: any) => parseFloat(Array.isArray(d) ? d[2] : d.high))
            .filter((h: number) => isFinite(h) && h > 0)
          const validLows = recent24h
            .map((d: any) => parseFloat(Array.isArray(d) ? d[3] : d.low))
            .filter((l: number) => isFinite(l) && l > 0)
            
          const high24h = validHighs.length > 0 ? Math.max(...validHighs) : currentPrice * 1.05
          const low24h = validLows.length > 0 ? Math.min(...validLows) : currentPrice * 0.95
          
          setMarketData(prev => ({
            ...prev!,
            sma20: sma20 || prev?.sma20 || 0,
            sma50: sma50 || prev?.sma50 || 0,
            sma200: sma200 || prev?.sma200 || 0,
            upperBand: (sma20 + (stdDev * 2)) || prev?.upperBand || 0,
            lowerBand: (sma20 - (stdDev * 2)) || prev?.lowerBand || 0,
            zScore: isFinite(zScore) ? zScore : 0,
            rsi: isFinite(rsi) && rsi >= 0 && rsi <= 100 ? rsi : 50,
            high24h: high24h || prev?.high24h || 0,
            low24h: low24h || prev?.low24h || 0
          }))
        } catch (calcError) {
          console.error('ÏßÄÌëú Í≥ÑÏÇ∞ Ïò§Î•ò:', calcError)
          // Í≥ÑÏÇ∞ Ïò§Î•ò Ïãú Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
          const coin = COINS.find(c => c.symbol === symbol)
          if (coin && prev) {
            setMarketData(prev => ({
              ...prev!,
              sma20: prev?.price || coin.initialPrice,
              sma50: prev?.price || coin.initialPrice,
              sma200: prev?.price || coin.initialPrice,
              upperBand: (prev?.price || coin.initialPrice) * 1.02,
              lowerBand: (prev?.price || coin.initialPrice) * 0.98,
              zScore: 0,
              rsi: 50,
              high24h: (prev?.price || coin.initialPrice) * 1.05,
              low24h: (prev?.price || coin.initialPrice) * 0.95
            }))
          }
        }
      }
    } catch (error: any) {
      console.error('Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®:', error)
      
      // ÏóêÎü¨ Ïãú Îπà Î∞∞Ïó¥ ÏÑ§Ï†ï
      setHistoricalData([])
      
      // ÏóêÎü¨ ÌÉÄÏûÖÏóê Îî∞Î•∏ Ï≤òÎ¶¨
      if (error.name === 'AbortError') {
        console.log('ÏöîÏ≤≠Ïù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§:', symbol)
      } else {
        // Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞Î°ú Ìè¥Î∞±
        const coin = COINS.find(c => c.symbol === symbol)
        if (coin) {
          setMarketData(prev => prev ? {
            ...prev,
            sma20: coin.initialPrice,
            sma50: coin.initialPrice,
            sma200: coin.initialPrice,
            upperBand: coin.initialPrice * 1.02,
            lowerBand: coin.initialPrice * 0.98,
            zScore: 0,
            rsi: 50
          } : null)
        }
      }
    } finally {
      setLoading(false)
    }
  }

  // ÏΩîÏù∏ Î≥ÄÍ≤Ω Ïãú
  useEffect(() => {
    setLoading(true)
    setMarketData({
      price: selectedCoin.initialPrice,
      change24h: 0,
      volume24h: 0,
      high24h: selectedCoin.initialPrice * 1.05,
      low24h: selectedCoin.initialPrice * 0.95,
      sma20: selectedCoin.initialPrice,
      sma50: selectedCoin.initialPrice,
      sma200: selectedCoin.initialPrice,
      upperBand: selectedCoin.initialPrice * 1.02,
      lowerBand: selectedCoin.initialPrice * 0.98,
      zScore: 0,
      rsi: 50
    })
    
    connectWebSocket(selectedCoin.symbol)
    loadHistoricalData(selectedCoin.symbol)

    return () => {
      // Ï†ïÎ¶¨ Ïãú Ïû¨Ïó∞Í≤∞ Î∞©ÏßÄ
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }
      
      if (wsRef.current) {
        // Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Ï†úÍ±∞Î°ú Ïû¨Ïó∞Í≤∞ Î∞©ÏßÄ
        wsRef.current.onclose = null
        wsRef.current.onerror = null
        wsRef.current.onmessage = null
        wsRef.current.onopen = null
        
        // Ï†ïÏÉÅ Ï¢ÖÎ£å ÏΩîÎìúÎ°ú Îã´Í∏∞
        if (wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.close(1000, 'Component unmounting')
        }
        wsRef.current = null
      }
    }
  }, [selectedCoin])

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-black to-gray-900">
      {/* Ìó§Îçî */}
      <div className="border-b border-gray-800 sticky top-0 bg-black/90 backdrop-blur-sm z-40">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <h1 className="text-2xl md:text-3xl font-bold text-white">
            ÌèâÍ∑†ÌöåÍ∑Ä Ï†ÑÎ¨∏ Î∂ÑÏÑù
          </h1>
          <p className="text-gray-400 text-sm md:text-base mt-1">
            Mean Reversion Strategy - Í∞ÄÍ≤©ÏùÄ Í≤∞Íµ≠ ÌèâÍ∑†ÏúºÎ°ú ÎèåÏïÑÏò®Îã§
          </p>
        </div>
      </div>

      {/* ÏΩîÏù∏ ÏÑ†ÌÉù */}
      <div className="sticky top-[73px] bg-black/90 backdrop-blur-sm z-30 border-b border-gray-800">
        <CoinSelector 
          coins={COINS}
          selectedCoin={selectedCoin}
          onSelectCoin={setSelectedCoin}
        />
      </div>

      {/* Î©îÏù∏ ÏΩòÌÖêÏ∏† */}
      <div className="max-w-7xl mx-auto px-4 py-6 space-y-6">
        {/* Í∞úÎÖê ÏÑ§Î™Ö ÏÑπÏÖò */}
        <ConceptSection coinName={selectedCoin.name} />

        {/* Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑù */}
        <RealtimeAnalysis 
          coin={selectedCoin}
          marketData={marketData}
          loading={loading}
        />

        {/* Ï∞®Ìä∏ ÏÑπÏÖò */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <PriceChart 
            coin={selectedCoin}
            historicalData={historicalData}
            marketData={marketData}
          />
          <BollingerBands 
            coin={selectedCoin}
            historicalData={historicalData}
            marketData={marketData}
          />
        </div>

        {/* ÏßÄÌëú Î∂ÑÏÑù */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <ZScoreAnalysis 
            coin={selectedCoin}
            marketData={marketData}
            historicalData={historicalData}
          />
          <RSIDivergence 
            coin={selectedCoin}
            marketData={marketData}
            historicalData={historicalData}
          />
        </div>

        {/* Ìä∏Î†àÏù¥Îî© ÏãúÍ∑∏ÎÑê */}
        <TradingSignals 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* Î∞±ÌÖåÏä§ÌåÖ Í≤∞Í≥º */}
        <BacktestResults 
          coin={selectedCoin}
          historicalData={historicalData}
        />

        {/* Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ */}
        <RiskManagement 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* Ï†ÑÎûµ Í∞ÄÏù¥Îìú */}
        <StrategyGuide 
          coin={selectedCoin}
          marketData={marketData}
        />

        {/* AI Ï∂îÏ≤ú */}
        <AIRecommendation 
          coin={selectedCoin}
          marketData={marketData}
        />
      </div>
    </div>
  )
}