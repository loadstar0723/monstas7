'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { BINANCE_CONFIG } from '@/lib/binanceConfig'
import { useWebSocketFirst } from '@/lib/useWebSocketFirst'
import CoinSelector from './components/CoinSelector'
import MomentumOverview from './components/MomentumOverview'
import PriceChart from './components/PriceChart'
import MomentumIndicators from './components/MomentumIndicators'
import VolumeAnalysis from './components/VolumeAnalysis'
import TrendStrength from './components/TrendStrength'
import SignalGenerator from './components/SignalGenerator'
import PositionSizer from './components/PositionSizer'
import RiskManager from './components/RiskManager'
import BacktestResults from './components/BacktestResults'
import LivePerformance from './components/LivePerformance'
import TradingStrategy from './components/TradingStrategy'

export interface CoinData {
  symbol: string
  name: string
  price: number
  change24h: number
  volume24h: number
  high24h: number
  low24h: number
  marketCap: number
}

export interface MomentumData {
  rsi: number
  macd: {
    macd: number
    signal: number
    histogram: number
  }
  stochastic: {
    k: number
    d: number
  }
  williams: number
  roc: number
  momentumScore: number
  trend: 'strong_bullish' | 'bullish' | 'neutral' | 'bearish' | 'strong_bearish'
}

const SUPPORTED_COINS = [
  { symbol: 'BTCUSDT', name: 'Bitcoin', icon: 'â‚¿' },
  { symbol: 'ETHUSDT', name: 'Ethereum', icon: 'Î' },
  { symbol: 'BNBUSDT', name: 'BNB', icon: 'ğŸ”¸' },
  { symbol: 'SOLUSDT', name: 'Solana', icon: 'â—' },
  { symbol: 'XRPUSDT', name: 'XRP', icon: 'âœ•' },
  { symbol: 'ADAUSDT', name: 'Cardano', icon: 'â‚³' },
  { symbol: 'DOGEUSDT', name: 'Dogecoin', icon: 'Ã' },
  { symbol: 'AVAXUSDT', name: 'Avalanche', icon: 'ğŸ”º' },
  { symbol: 'MATICUSDT', name: 'Polygon', icon: 'â¬¡' },
  { symbol: 'DOTUSDT', name: 'Polkadot', icon: 'â—' }
]

export default function MomentumModule() {
  const [selectedCoin, setSelectedCoin] = useState('BTCUSDT')
  const [coinData, setCoinData] = useState<CoinData | null>(null)
  const [momentumData, setMomentumData] = useState<MomentumData | null>(null)
  const [priceHistory, setPriceHistory] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [connectionStatus, setConnectionStatus] = useState<'disconnected' | 'connecting' | 'connected' | 'error'>('disconnected')
  const wsRef = useRef<WebSocket | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const lastUpdateRef = useRef<number>(0)

  // WebSocket ë°ì´í„° ì²˜ë¦¬
  const handleWebSocketData = useCallback((data: any) => {
    // ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ì²˜ë¦¬
    if (data.stream && data.data) {
      const streamData = data.data
      
      // 24ì‹œê°„ í‹°ì»¤ ë°ì´í„° ì²˜ë¦¬
      if (streamData.e === '24hrTicker') {
        const coin = SUPPORTED_COINS.find(c => c.symbol === streamData.s)
        setCoinData({
          symbol: streamData.s,
          name: coin?.name || streamData.s,
          price: parseFloat(streamData.c),
          change24h: parseFloat(streamData.P),
          volume24h: parseFloat(streamData.v),
          high24h: parseFloat(streamData.h),
          low24h: parseFloat(streamData.l),
          marketCap: parseFloat(streamData.q)
        })
        setConnectionStatus('connected')
      }
      // 1ë¶„ ìº”ë“¤ ë°ì´í„° ì²˜ë¦¬
      else if (streamData.e === 'kline' && streamData.k) {
        const kline = streamData.k
        
        // ì‹¤ì‹œê°„ ìº”ë“¤ ì—…ë°ì´íŠ¸ (ë‹«íˆì§€ ì•Šì€ ìº”ë“¤ë„ í¬í•¨)
        setPriceHistory(prev => {
          const newCandle = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
          }
          
          // ê¸°ì¡´ ìº”ë“¤ ì—…ë°ì´íŠ¸ ë˜ëŠ” ìƒˆ ìº”ë“¤ ì¶”ê°€
          if (prev.length > 0 && prev[prev.length - 1].time === kline.t) {
            // ê°™ì€ ì‹œê°„ì˜ ìº”ë“¤ ì—…ë°ì´íŠ¸
            return [...prev.slice(0, -1), newCandle]
          } else if (kline.x) {
            // ìƒˆë¡œìš´ ìº”ë“¤ ì¶”ê°€ (ìº”ë“¤ì´ ë‹«í˜”ì„ ë•Œ)
            return [...prev, newCandle].slice(-100)
          } else {
            // ì²« ë°ì´í„°ì´ê±°ë‚˜ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
            return prev.length === 0 ? [newCandle] : prev
          }
        })
      }
    }
    // ë‹¨ìˆœ í‹°ì»¤ ë°ì´í„° ì²˜ë¦¬ (ì´ì „ í˜•ì‹ í˜¸í™˜)
    else if (data.e === '24hrTicker' || data.s) {
      const coin = SUPPORTED_COINS.find(c => c.symbol === (data.s || data.symbol))
      if (data.c || data.lastPrice) {
        setCoinData({
          symbol: data.s || data.symbol,
          name: coin?.name || data.s || data.symbol,
          price: parseFloat(data.c || data.lastPrice),
          change24h: parseFloat(data.P || data.priceChangePercent || '0'),
          volume24h: parseFloat(data.v || data.volume || '0'),
          high24h: parseFloat(data.h || data.highPrice || '0'),
          low24h: parseFloat(data.l || data.lowPrice || '0'),
          marketCap: parseFloat(data.q || data.quoteVolume || '0')
        })
        setConnectionStatus('connected')
      }
    }
  }, [])

  // WebSocket ì—ëŸ¬ ì²˜ë¦¬
  const handleWebSocketError = useCallback((error: any) => {
    console.error('WebSocket error:', error)
    setConnectionStatus('error')
    // ì—ëŸ¬ ì‹œ í´ë°±ìœ¼ë¡œ REST API ì‚¬ìš©
    if (selectedCoin) {
      fetchCoinDataWithRateLimit(selectedCoin)
    }
  }, [selectedCoin])

  // WebSocket ìš°ì„  ì‚¬ìš© í›…
  const { isConnected } = useWebSocketFirst({
    symbol: selectedCoin,
    onData: handleWebSocketData,
    onError: handleWebSocketError,
    autoReconnect: true,
    maxReconnectAttempts: 5
  })

  // ë ˆì´íŠ¸ ë¦¬ë°‹ ì ìš© ì½”ì¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ê°•í™”ëœ ì—ëŸ¬ ì²˜ë¦¬)
  const fetchCoinDataWithRateLimit = useCallback(async (symbol: string) => {
    try {
      setError(null)
      // ìµœì†Œ 100ms ê°„ê²© ì²´í¬
      const now = Date.now()
      if (now - lastUpdateRef.current < 100) {
        return // ë„ˆë¬´ ë¹ ë¥¸ ìš”ì²­ ë°©ì§€
      }
      lastUpdateRef.current = now

      const response = await fetch(`/api/binance/ticker?symbol=${symbol}`, {
        timeout: 10000, // 10ì´ˆ íƒ€ì„ì•„ì›ƒ
        signal: AbortSignal.timeout(10000)
      })
      
      // response.ok ì²´í¬ ê°•í™”
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached for', symbol)
          setError('API ë ˆì´íŠ¸ ë¦¬ë°‹ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. WebSocket ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.')
          return
        }
        if (response.status === 404) {
          throw new Error(`ì‹¬ë³¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${symbol}`)
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const data = await response.json()
      
      // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬ ê°•í™”
      if (!data || typeof data !== 'object') {
        throw new Error('Invalid API response format')
      }
      if (!data.symbol || data.symbol !== symbol) {
        throw new Error('Symbol mismatch in response')
      }
      
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      
      setCoinData({
        symbol: data.symbol,
        name: coin?.name || symbol,
        price: parseFloat(data.lastPrice) || 0,
        change24h: parseFloat(data.priceChangePercent) || 0,
        volume24h: parseFloat(data.volume) || 0,
        high24h: parseFloat(data.highPrice) || 0,
        low24h: parseFloat(data.lowPrice) || 0,
        marketCap: parseFloat(data.quoteVolume) || 0
      })
    } catch (err: any) {
      console.error('Error fetching coin data:', err)
      
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      const defaultPrice = coin?.symbol === 'BTCUSDT' ? 98000 :
                          coin?.symbol === 'ETHUSDT' ? 3500 :
                          coin?.symbol === 'BNBUSDT' ? 700 :
                          coin?.symbol === 'SOLUSDT' ? 240 :
                          coin?.symbol === 'XRPUSDT' ? 2.5 : 100
      
      setCoinData({
        symbol: symbol,
        name: coin?.name || symbol,
        price: defaultPrice,
        change24h: 0,
        volume24h: 0,
        high24h: defaultPrice * 1.05,
        low24h: defaultPrice * 0.95,
        marketCap: 0
      })
      
      setError(err.name === 'AbortError' ? 'ìš”ì²­ ì‹œê°„ ì´ˆê³¼' : 'ë°ì´í„° ë¡œë“œ ì¤‘... WebSocket ì—°ê²° ëŒ€ê¸° ì¤‘')
    }
  }, [])

  // íˆìŠ¤í† ë¦¬ì»¬ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ë ˆì´íŠ¸ ë¦¬ë°‹ ì ìš©)
  const fetchHistoricalData = useCallback(async (symbol: string) => {
    try {
      setError(null)
      const response = await fetch(
        `/api/binance/klines?symbol=${symbol}&interval=1h&limit=100`
      )
      
      // response.ok ì²´í¬ ê°•í™”
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached, using WebSocket data only')
          return // WebSocket ë°ì´í„°ë§Œ ì‚¬ìš©
        }
        throw new Error(`HTTP ${response.status}: Failed to fetch historical data`)
      }
      
      const result = await response.json()
      
      // API ì‘ë‹µ êµ¬ì¡° í™•ì¸
      const data = result.klines || result.data || result
      
      // dataê°€ ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° ì²˜ë¦¬
      if (!Array.isArray(data)) {
        console.warn('Invalid data format, using WebSocket data only')
        return
      }
      
      // ë°ì´í„°ê°€ ë¹„ì–´ìˆëŠ” ê²½ìš° ì²˜ë¦¬
      if (data.length === 0) {
        console.warn('Empty data received, using WebSocket data only')
        return
      }
      
      // ì´ë¯¸ ì²˜ë¦¬ëœ ë°ì´í„°ì¸ì§€ í™•ì¸
      if (data[0].time) {
        // ì´ë¯¸ ì²˜ë¦¬ëœ ë°ì´í„°
        setPriceHistory(data)
      } else if (Array.isArray(data[0])) {
        // ì›ì‹œ Binance ë°ì´í„° ì²˜ë¦¬
        const history = data.map((item: any[]) => ({
          time: item[0],
          open: parseFloat(item[1]) || 0,
          high: parseFloat(item[2]) || 0,
          low: parseFloat(item[3]) || 0,
          close: parseFloat(item[4]) || 0,
          volume: parseFloat(item[5]) || 0
        }))
        setPriceHistory(history)
      } else if (data[0].openTime) {
        // APIì—ì„œ ì²˜ë¦¬ëœ ë°ì´í„°
        const history = data.map((item: any) => ({
          time: item.openTime,
          open: parseFloat(item.open) || 0,
          high: parseFloat(item.high) || 0,
          low: parseFloat(item.low) || 0,
          close: parseFloat(item.close) || 0,
          volume: parseFloat(item.volume) || 0
        }))
        setPriceHistory(history)
      }
    } catch (err) {
      console.error('Error fetching historical data:', err)
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •
      setPriceHistory([])
      setError(null) // ì—ëŸ¬ ë©”ì‹œì§€ ìˆ¨ê¹€ (WebSocket ë°ì´í„° ìš°ì„  ì‚¬ìš©)
    }
  }, [])

  // ëª¨ë©˜í…€ ì§€í‘œ ê³„ì‚°
  const calculateMomentumIndicators = (data: any[]) => {
    if (data.length < 14) return

    const closes = data.map(d => d.close)
    
    // RSI ê³„ì‚°
    const rsi = calculateRSI(closes, 14)
    
    // MACD ê³„ì‚°
    const macd = calculateMACD(closes)
    
    // Stochastic ê³„ì‚°
    const stochastic = calculateStochastic(data, 14, 3)
    
    // Williams %R ê³„ì‚°
    const williams = calculateWilliams(data, 14)
    
    // ROC ê³„ì‚°
    const roc = calculateROC(closes, 12)
    
    // ëª¨ë©˜í…€ ìŠ¤ì½”ì–´ ê³„ì‚°
    const momentumScore = calculateMomentumScore(rsi, macd, stochastic, williams, roc)
    
    // íŠ¸ë Œë“œ íŒë‹¨
    const trend = determineTrend(momentumScore, rsi, macd)
    
    setMomentumData({
      rsi,
      macd,
      stochastic,
      williams,
      roc,
      momentumScore,
      trend
    })
  }

  // RSI ê³„ì‚°
  const calculateRSI = (prices: number[], period: number = 14): number => {
    if (prices.length < period + 1) return 50

    let gains = 0
    let losses = 0

    for (let i = prices.length - period; i < prices.length; i++) {
      const change = prices[i] - prices[i - 1]
      if (change > 0) {
        gains += change
      } else {
        losses -= change
      }
    }

    const avgGain = gains / period
    const avgLoss = losses / period
    
    if (avgLoss === 0) return 100
    
    const rs = avgGain / avgLoss
    return 100 - (100 / (1 + rs))
  }

  // MACD ê³„ì‚°
  const calculateMACD = (prices: number[]) => {
    const ema12 = calculateEMA(prices, 12)
    const ema26 = calculateEMA(prices, 26)
    const macdLine = ema12 - ema26
    const signalLine = calculateEMA([macdLine], 9)
    
    return {
      macd: macdLine,
      signal: signalLine,
      histogram: macdLine - signalLine
    }
  }

  // EMA ê³„ì‚°
  const calculateEMA = (data: number[], period: number): number => {
    if (data.length < period) return data[data.length - 1]
    
    const multiplier = 2 / (period + 1)
    let ema = data.slice(0, period).reduce((a, b) => a + b) / period
    
    for (let i = period; i < data.length; i++) {
      ema = (data[i] - ema) * multiplier + ema
    }
    
    return ema
  }

  // Stochastic ê³„ì‚°
  const calculateStochastic = (data: any[], period: number, smooth: number) => {
    const highs = data.slice(-period).map(d => d.high)
    const lows = data.slice(-period).map(d => d.low)
    const close = data[data.length - 1].close
    
    const highest = Math.max(...highs)
    const lowest = Math.min(...lows)
    
    const k = ((close - lowest) / (highest - lowest)) * 100
    const d = k // Simplified for now
    
    return { k, d }
  }

  // Williams %R ê³„ì‚°
  const calculateWilliams = (data: any[], period: number): number => {
    const highs = data.slice(-period).map(d => d.high)
    const lows = data.slice(-period).map(d => d.low)
    const close = data[data.length - 1].close
    
    const highest = Math.max(...highs)
    const lowest = Math.min(...lows)
    
    return ((highest - close) / (highest - lowest)) * -100
  }

  // ROC ê³„ì‚°
  const calculateROC = (prices: number[], period: number): number => {
    if (prices.length < period + 1) return 0
    
    const currentPrice = prices[prices.length - 1]
    const pastPrice = prices[prices.length - 1 - period]
    
    return ((currentPrice - pastPrice) / pastPrice) * 100
  }

  // ëª¨ë©˜í…€ ìŠ¤ì½”ì–´ ê³„ì‚°
  const calculateMomentumScore = (
    rsi: number,
    macd: any,
    stochastic: any,
    williams: number,
    roc: number
  ): number => {
    let score = 0
    
    // RSI ì ìˆ˜ (0-25ì )
    if (rsi > 70) score += 25
    else if (rsi > 60) score += 20
    else if (rsi > 50) score += 15
    else if (rsi > 40) score += 10
    else if (rsi > 30) score += 5
    
    // MACD ì ìˆ˜ (0-25ì )
    if (macd.histogram > 0) score += 25
    else score += 10
    
    // Stochastic ì ìˆ˜ (0-25ì )
    if (stochastic.k > 80) score += 25
    else if (stochastic.k > 60) score += 20
    else if (stochastic.k > 40) score += 15
    else if (stochastic.k > 20) score += 10
    else score += 5
    
    // Williams %R ì ìˆ˜ (0-25ì )
    if (williams > -20) score += 25
    else if (williams > -40) score += 20
    else if (williams > -60) score += 15
    else if (williams > -80) score += 10
    else score += 5
    
    return Math.min(100, score)
  }

  // íŠ¸ë Œë“œ íŒë‹¨
  const determineTrend = (score: number, rsi: number, macd: any): MomentumData['trend'] => {
    if (score > 80 && rsi > 70) return 'strong_bullish'
    if (score > 60) return 'bullish'
    if (score < 20 && rsi < 30) return 'strong_bearish'
    if (score < 40) return 'bearish'
    return 'neutral'
  }

  // í´ë§ í´ë°± í•¨ìˆ˜
  const startPolling = useCallback((symbol: string) => {
    console.log('Starting polling for', symbol)
    
    // ê¸°ì¡´ í´ë§ ì •ë¦¬
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current)
    }
    
    // ì¦‰ì‹œ í•œ ë²ˆ ì—…ë°ì´íŠ¸
    fetchTickerData(symbol)
    
    // 3ì´ˆë§ˆë‹¤ ê°€ê²© ì—…ë°ì´íŠ¸
    pollingIntervalRef.current = setInterval(async () => {
      try {
        await fetchTickerData(symbol)
      } catch (err) {
        console.error('Polling error:', err)
      }
    }, 3000) as any
  }, [])
  
  // í‹°ì»¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (API ë¼ìš°íŠ¸ ì‚¬ìš©)
  const fetchTickerData = useCallback(async (symbol: string) => {
    try {
      const response = await fetch(`/api/ticker-stream?symbol=${symbol}`)
      if (!response.ok) throw new Error('Failed to fetch ticker')
      
      const data = await response.json()
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      
      setCoinData({
        symbol: data.s,
        name: coin?.name || symbol,
        price: parseFloat(data.c),
        change24h: parseFloat(data.P),
        volume24h: parseFloat(data.v),
        high24h: parseFloat(data.h),
        low24h: parseFloat(data.l),
        marketCap: parseFloat(data.q)
      })
    } catch (err) {
      console.error('Ticker fetch error:', err)
    }
  }, [])

  // WebSocket ì—°ê²° (try-catch ê°•í™”)
  const connectWebSocket = useCallback((symbol: string) => {
    try {
      // ê¸°ì¡´ ì—°ê²° ì •ë¦¬
      if (wsRef.current) {
        try {
          if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
            wsRef.current.close(1000, 'Switching to new connection')
          }
        } catch (closeError) {
          console.warn('Error closing previous WebSocket:', closeError)
        }
        wsRef.current = null
      }

      // ì¬ì—°ê²° íƒ€ì´ë¨¸ ì •ë¦¬
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }

      const streamName = symbol.toLowerCase() + '@ticker'
      const wsUrl = `${BINANCE_CONFIG.WS_BASE}/${streamName}`
      console.log('Connecting to WebSocket:', wsUrl)
      
      let ws: WebSocket
      try {
        ws = new WebSocket(wsUrl)
      } catch (wsCreateError) {
        console.error('Failed to create WebSocket:', wsCreateError)
        setError('WebSocket ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì¬ì‹œë„ ì¤‘...')
        setConnectionStatus('error')
        
        // 5ì´ˆ í›„ ì¬ì‹œë„
        reconnectTimeoutRef.current = setTimeout(() => {
          connectWebSocket(symbol)
        }, 5000)
        return
      }
      
      wsRef.current = ws
      setConnectionStatus('connecting')

      // ì—°ê²° íƒ€ì„ì•„ì›ƒ ì„¤ì • (10ì´ˆ)
      const connectionTimeout = setTimeout(() => {
        if (ws.readyState !== WebSocket.OPEN) {
          console.error('WebSocket connection timeout')
          try {
            ws.close(1000, 'Connection timeout')
          } catch (timeoutCloseError) {
            console.warn('Error closing timed out WebSocket:', timeoutCloseError)
          }
          setError('WebSocket ì—°ê²° ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤.')
          setConnectionStatus('disconnected')
          
          // ì¬ì—°ê²° ì‹œë„
          reconnectTimeoutRef.current = setTimeout(() => {
            connectWebSocket(symbol)
          }, 5000)
        }
      }, 10000)

      ws.onopen = () => {
        clearTimeout(connectionTimeout)
        console.log('WebSocket connected:', symbol)
        setConnectionStatus('connected')
        setError(null)
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          
          // ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
          if (!data || !data.s || !data.c) {
            console.warn('Invalid WebSocket data received:', data)
            return
          }
          
          const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
          setCoinData(prev => ({
            symbol: data.s,
            name: coin?.name || symbol,
            price: parseFloat(data.c) || prev?.price || 0,
            change24h: parseFloat(data.P) || prev?.change24h || 0,
            volume24h: parseFloat(data.v) || prev?.volume24h || 0,
            high24h: parseFloat(data.h) || prev?.high24h || 0,
            low24h: parseFloat(data.l) || prev?.low24h || 0,
            marketCap: parseFloat(data.q) || prev?.marketCap || 0
          }))
        } catch (parseError) {
          console.error('Error parsing WebSocket message:', parseError)
          // íŒŒì‹± ì—ëŸ¬ ì‹œì—ë„ ì—°ê²°ì€ ìœ ì§€
        }
      }

      ws.onerror = (event) => {
        clearTimeout(connectionTimeout)
        console.error('WebSocket error occurred:', {
          url: wsUrl,
          readyState: ws.readyState,
          event: event
        })
        setError('WebSocket ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì¬ì—°ê²° ì¤‘...')
        setConnectionStatus('error')
      }

      ws.onclose = (event) => {
        clearTimeout(connectionTimeout)
        console.log('WebSocket disconnected. Code:', event.code, 'Reason:', event.reason)
        setConnectionStatus('disconnected')
        wsRef.current = null

        // ì •ìƒì ì¸ ì¢…ë£Œê°€ ì•„ë‹Œ ê²½ìš° ì¬ì—°ê²° ì‹œë„
        if (event.code !== 1000 && event.code !== 1001) {
          const attempts = (ws as any)?.reconnectAttempts || 0
          if (attempts < 3) {
            console.log(`Attempting to reconnect WebSocket... (attempt ${attempts + 1}/3)`)
            reconnectTimeoutRef.current = setTimeout(() => {
              const newWs = wsRef.current
              if (newWs) {
                (newWs as any).reconnectAttempts = attempts + 1
              }
              connectWebSocket(symbol)
            }, 5000)
          } else {
            console.log('WebSocket reconnection failed, using fallback')
            setError('ì‹¤ì‹œê°„ ì—°ê²°ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ëŒ€ì²´ ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.')
            // í´ë§ ëŒ€ì‹  ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
            fetchCoinDataWithRateLimit(symbol)
          }
        }
      }
    } catch (error) {
      console.error('Error in WebSocket setup:', error)
      setError('WebSocket ì„¤ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.')
      setConnectionStatus('error')
      
      // ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ í´ë°±
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      const defaultPrice = coin?.symbol === 'BTCUSDT' ? 98000 :
                          coin?.symbol === 'ETHUSDT' ? 3500 :
                          coin?.symbol === 'BNBUSDT' ? 700 : 0
      
      setCoinData({
        symbol: symbol,
        name: coin?.name || symbol,
        price: defaultPrice,
        change24h: 0,
        volume24h: 0,
        high24h: defaultPrice * 1.05,
        low24h: defaultPrice * 0.95,
        marketCap: 0
      })
      
      // ì¬ì—°ê²° ì‹œë„
      reconnectTimeoutRef.current = setTimeout(() => {
        connectWebSocket(symbol)
      }, 5000)
    }
  }, [selectedCoin, fetchCoinDataWithRateLimit])

  // ì½”ì¸ ë³€ê²½ ì‹œ
  useEffect(() => {
    setLoading(true)
    setError(null)
    
    // ë°ì´í„° ì´ˆê¸°í™”í•˜ì§€ ì•Šê³  ìœ ì§€ (ê¹œë¹¡ì„ ë°©ì§€)
    // setCoinData(null)
    // setMomentumData(null)
    // setPriceHistory([])
    
    // íˆìŠ¤í† ë¦¬ì»¬ ë°ì´í„° ì¦‰ì‹œ ê°€ì ¸ì˜¤ê¸°
    fetchHistoricalData(selectedCoin)
    
    // WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ì„ ë•Œë§Œ REST API ì‚¬ìš©
    if (!isConnected) {
      fetchCoinDataWithRateLimit(selectedCoin)
    }
    
    // ë¡œë”© ì™„ë£Œ (ë” ë¹ ë¥´ê²Œ)
    const timer = setTimeout(() => setLoading(false), 500)
    
    return () => {
      clearTimeout(timer)
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
    }
  }, [selectedCoin, isConnected, fetchCoinDataWithRateLimit, fetchHistoricalData])

  // ê°€ê²© íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ ì‹œ ëª¨ë©˜í…€ ì§€í‘œ ê³„ì‚°
  useEffect(() => {
    if (priceHistory.length >= 14) {
      calculateMomentumIndicators(priceHistory)
    }
  }, [priceHistory])

  // WebSocket ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
  useEffect(() => {
    setConnectionStatus(isConnected ? 'connected' : 'disconnected')
  }, [isConnected])

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬
  useEffect(() => {
    return () => {
      if (wsRef.current) {
        wsRef.current.close(1000, 'Component unmounting')
      }
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current)
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
    }
  }, [])

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-400">ëª¨ë©˜í…€ ë°ì´í„° ë¶„ì„ ì¤‘...</p>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900 flex items-center justify-center">
        <div className="text-center bg-red-500/10 border border-red-500/20 rounded-lg p-6">
          <p className="text-red-400 mb-2">ì˜¤ë¥˜ ë°œìƒ</p>
          <p className="text-gray-400">{error}</p>
          <button 
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors"
          >
            ìƒˆë¡œê³ ì¹¨
          </button>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900">
      {/* ì½”ì¸ ì„ íƒê¸° */}
      <CoinSelector 
        coins={SUPPORTED_COINS}
        selectedCoin={selectedCoin}
        onSelectCoin={setSelectedCoin}
        coinData={coinData}
      />

      {/* WebSocket ì—°ê²° ìƒíƒœ */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-2 pb-0">
        <div className="flex items-center justify-end gap-2 text-sm">
          <div className={`flex items-center gap-2 ${
            isConnected ? 'text-green-400' : 
            connectionStatus === 'connecting' ? 'text-yellow-400' : 
            connectionStatus === 'error' ? 'text-red-400' : 'text-gray-400'
          }`}>
            <div className={`w-2 h-2 rounded-full ${
              isConnected ? 'bg-green-400' : 
              connectionStatus === 'connecting' ? 'bg-yellow-400 animate-pulse' : 
              connectionStatus === 'error' ? 'bg-red-400' : 'bg-gray-400'
            }`} />
            <span>
              {connectionStatus === 'connected' ? 'ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹  ì¤‘' :
               connectionStatus === 'connecting' ? 'ë°ì´í„° ì—°ê²° ì¤‘...' :
               connectionStatus === 'error' ? 'ì—°ê²° ì˜¤ë¥˜' : 'ì—°ê²° ëŠê¹€'}
            </span>
          </div>
          {error && (
            <div className="text-red-400 text-xs">
              {error}
            </div>
          )}
        </div>
      </div>

      {/* ë©”ì¸ ëŒ€ì‹œë³´ë“œ */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6">
        {/* ëª¨ë©˜í…€ ê°œìš” */}
        <MomentumOverview coinData={coinData} momentumData={momentumData} />

        {/* ê°€ê²© ì°¨íŠ¸ */}
        <PriceChart 
          symbol={selectedCoin}
          priceHistory={priceHistory}
          currentPrice={coinData?.price || 0}
          momentumData={momentumData}
        />

        {/* ëª¨ë©˜í…€ ì§€í‘œ */}
        <MomentumIndicators momentumData={momentumData} />

        {/* ê±°ë˜ëŸ‰ ë¶„ì„ */}
        <VolumeAnalysis 
          symbol={selectedCoin}
          volumeData={priceHistory}
        />

        {/* ì¶”ì„¸ ê°•ë„ */}
        <TrendStrength 
          momentumData={momentumData}
          priceHistory={priceHistory}
        />

        {/* ì‹ í˜¸ ìƒì„±ê¸° */}
        <SignalGenerator 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* í¬ì§€ì…˜ ì‚¬ì´ì € */}
        <PositionSizer 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* ë¦¬ìŠ¤í¬ ê´€ë¦¬ */}
        <RiskManager 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* ë°±í…ŒìŠ¤íŒ… ê²°ê³¼ */}
        <BacktestResults 
          symbol={selectedCoin}
          priceHistory={priceHistory}
        />

        {/* ì‹¤ì‹œê°„ ì„±ê³¼ */}
        <LivePerformance 
          symbol={selectedCoin}
          momentumData={momentumData}
        />

        {/* ì¢…í•© íŠ¸ë ˆì´ë”© ì „ëµ */}
        <TradingStrategy 
          momentumData={momentumData}
          coinData={coinData}
        />
      </div>
    </div>
  )
}