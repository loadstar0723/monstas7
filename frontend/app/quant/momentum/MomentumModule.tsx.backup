'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { BINANCE_CONFIG } from '@/lib/binanceConfig'
import { useWebSocketFirst } from '@/lib/useWebSocketFirst'
import CoinSelector from './components/CoinSelector'
import MomentumOverview from './components/MomentumOverview'
import PriceChart from './components/PriceChart'
import MomentumIndicators from './components/MomentumIndicators'
import VolumeAnalysis from './components/VolumeAnalysis'
import TrendStrength from './components/TrendStrength'
import SignalGenerator from './components/SignalGenerator'
import PositionSizer from './components/PositionSizer'
import RiskManager from './components/RiskManager'
import BacktestResults from './components/BacktestResults'
import LivePerformance from './components/LivePerformance'
import TradingStrategy from './components/TradingStrategy'

export interface CoinData {
  symbol: string
  name: string
  price: number
  change24h: number
  volume24h: number
  high24h: number
  low24h: number
  marketCap: number
}

export interface MomentumData {
  rsi: number
  macd: {
    macd: number
    signal: number
    histogram: number
  }
  stochastic: {
    k: number
    d: number
  }
  williams: number
  roc: number
  momentumScore: number
  trend: 'strong_bullish' | 'bullish' | 'neutral' | 'bearish' | 'strong_bearish'
}

const SUPPORTED_COINS = [
  { symbol: 'BTCUSDT', name: 'Bitcoin', icon: '₿' },
  { symbol: 'ETHUSDT', name: 'Ethereum', icon: 'Ξ' },
  { symbol: 'BNBUSDT', name: 'BNB', icon: '🔸' },
  { symbol: 'SOLUSDT', name: 'Solana', icon: '◎' },
  { symbol: 'XRPUSDT', name: 'XRP', icon: '✕' },
  { symbol: 'ADAUSDT', name: 'Cardano', icon: '₳' },
  { symbol: 'DOGEUSDT', name: 'Dogecoin', icon: 'Ð' },
  { symbol: 'AVAXUSDT', name: 'Avalanche', icon: '🔺' },
  { symbol: 'MATICUSDT', name: 'Polygon', icon: '⬡' },
  { symbol: 'DOTUSDT', name: 'Polkadot', icon: '●' }
]

export default function MomentumModule() {
  const [selectedCoin, setSelectedCoin] = useState('BTCUSDT')
  const [coinData, setCoinData] = useState<CoinData | null>(null)
  const [momentumData, setMomentumData] = useState<MomentumData | null>(null)
  const [priceHistory, setPriceHistory] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [connectionStatus, setConnectionStatus] = useState<'disconnected' | 'connecting' | 'connected' | 'error'>('disconnected')
  const wsRef = useRef<WebSocket | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null)
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null)
  const lastUpdateRef = useRef<number>(0)

  // WebSocket 데이터 처리
  const handleWebSocketData = useCallback((data: any) => {
    // 스트림 데이터 처리
    if (data.stream && data.data) {
      const streamData = data.data
      
      // 24시간 티커 데이터 처리
      if (streamData.e === '24hrTicker') {
        const coin = SUPPORTED_COINS.find(c => c.symbol === streamData.s)
        setCoinData({
          symbol: streamData.s,
          name: coin?.name || streamData.s,
          price: parseFloat(streamData.c),
          change24h: parseFloat(streamData.P),
          volume24h: parseFloat(streamData.v),
          high24h: parseFloat(streamData.h),
          low24h: parseFloat(streamData.l),
          marketCap: parseFloat(streamData.q)
        })
        setConnectionStatus('connected')
      }
      // 1분 캔들 데이터 처리
      else if (streamData.e === 'kline' && streamData.k) {
        const kline = streamData.k
        
        // 실시간 캔들 업데이트 (닫히지 않은 캔들도 포함)
        setPriceHistory(prev => {
          const newCandle = {
            time: kline.t,
            open: parseFloat(kline.o),
            high: parseFloat(kline.h),
            low: parseFloat(kline.l),
            close: parseFloat(kline.c),
            volume: parseFloat(kline.v)
          }
          
          // 기존 캔들 업데이트 또는 새 캔들 추가
          if (prev.length > 0 && prev[prev.length - 1].time === kline.t) {
            // 같은 시간의 캔들 업데이트
            return [...prev.slice(0, -1), newCandle]
          } else if (kline.x) {
            // 새로운 캔들 추가 (캔들이 닫혔을 때)
            return [...prev, newCandle].slice(-100)
          } else {
            // 첫 데이터이거나 실시간 업데이트
            return prev.length === 0 ? [newCandle] : prev
          }
        })
      }
    }
    // 단순 티커 데이터 처리 (이전 형식 호환)
    else if (data.e === '24hrTicker' || data.s) {
      const coin = SUPPORTED_COINS.find(c => c.symbol === (data.s || data.symbol))
      if (data.c || data.lastPrice) {
        setCoinData({
          symbol: data.s || data.symbol,
          name: coin?.name || data.s || data.symbol,
          price: parseFloat(data.c || data.lastPrice),
          change24h: parseFloat(data.P || data.priceChangePercent || '0'),
          volume24h: parseFloat(data.v || data.volume || '0'),
          high24h: parseFloat(data.h || data.highPrice || '0'),
          low24h: parseFloat(data.l || data.lowPrice || '0'),
          marketCap: parseFloat(data.q || data.quoteVolume || '0')
        })
        setConnectionStatus('connected')
      }
    }
  }, [])

  // WebSocket 에러 처리
  const handleWebSocketError = useCallback((error: any) => {
    console.error('WebSocket error:', error)
    setConnectionStatus('error')
    // 에러 시 폴백으로 REST API 사용
    if (selectedCoin) {
      fetchCoinDataWithRateLimit(selectedCoin)
    }
  }, [selectedCoin])

  // WebSocket 우선 사용 훅
  const { isConnected } = useWebSocketFirst({
    symbol: selectedCoin,
    onData: handleWebSocketData,
    onError: handleWebSocketError,
    autoReconnect: true,
    maxReconnectAttempts: 5
  })

  // 레이트 리밋 적용 코인 정보 가져오기 (강화된 에러 처리)
  const fetchCoinDataWithRateLimit = useCallback(async (symbol: string) => {
    try {
      setError(null)
      // 최소 100ms 간격 체크
      const now = Date.now()
      if (now - lastUpdateRef.current < 100) {
        return // 너무 빠른 요청 방지
      }
      lastUpdateRef.current = now

      const response = await fetch(`/api/binance/ticker?symbol=${symbol}`, {
        timeout: 10000, // 10초 타임아웃
        signal: AbortSignal.timeout(10000)
      })
      
      // response.ok 체크 강화
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached for', symbol)
          setError('API 레이트 리밋에 도달했습니다. WebSocket 데이터를 사용합니다.')
          return
        }
        if (response.status === 404) {
          throw new Error(`심볼을 찾을 수 없습니다: ${symbol}`)
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const data = await response.json()
      
      // 데이터 유효성 검사 강화
      if (!data || typeof data !== 'object') {
        throw new Error('Invalid API response format')
      }
      if (!data.symbol || data.symbol !== symbol) {
        throw new Error('Symbol mismatch in response')
      }
      
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      
      setCoinData({
        symbol: data.symbol,
        name: coin?.name || symbol,
        price: parseFloat(data.lastPrice) || 0,
        change24h: parseFloat(data.priceChangePercent) || 0,
        volume24h: parseFloat(data.volume) || 0,
        high24h: parseFloat(data.highPrice) || 0,
        low24h: parseFloat(data.lowPrice) || 0,
        marketCap: parseFloat(data.quoteVolume) || 0
      })
    } catch (err: any) {
      console.error('Error fetching coin data:', err)
      
      // 에러 시 기본값으로 폴백
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      const defaultPrice = coin?.symbol === 'BTCUSDT' ? 98000 :
                          coin?.symbol === 'ETHUSDT' ? 3500 :
                          coin?.symbol === 'BNBUSDT' ? 700 :
                          coin?.symbol === 'SOLUSDT' ? 240 :
                          coin?.symbol === 'XRPUSDT' ? 2.5 : 100
      
      setCoinData({
        symbol: symbol,
        name: coin?.name || symbol,
        price: defaultPrice,
        change24h: 0,
        volume24h: 0,
        high24h: defaultPrice * 1.05,
        low24h: defaultPrice * 0.95,
        marketCap: 0
      })
      
      setError(err.name === 'AbortError' ? '요청 시간 초과' : '데이터 로드 중... WebSocket 연결 대기 중')
    }
  }, [])

  // 히스토리컬 데이터 가져오기 (레이트 리밋 적용)
  const fetchHistoricalData = useCallback(async (symbol: string) => {
    try {
      setError(null)
      const response = await fetch(
        `/api/binance/klines?symbol=${symbol}&interval=1h&limit=100`
      )
      
      // response.ok 체크 강화
      if (!response.ok) {
        if (response.status === 429) {
          console.warn('Rate limit reached, using WebSocket data only')
          return // WebSocket 데이터만 사용
        }
        throw new Error(`HTTP ${response.status}: Failed to fetch historical data`)
      }
      
      const result = await response.json()
      
      // API 응답 구조 확인
      const data = result.klines || result.data || result
      
      // data가 배열이 아닌 경우 처리
      if (!Array.isArray(data)) {
        console.warn('Invalid data format, using WebSocket data only')
        return
      }
      
      // 데이터가 비어있는 경우 처리
      if (data.length === 0) {
        console.warn('Empty data received, using WebSocket data only')
        return
      }
      
      // 이미 처리된 데이터인지 확인
      if (data[0].time) {
        // 이미 처리된 데이터
        setPriceHistory(data)
      } else if (Array.isArray(data[0])) {
        // 원시 Binance 데이터 처리
        const history = data.map((item: any[]) => ({
          time: item[0],
          open: parseFloat(item[1]) || 0,
          high: parseFloat(item[2]) || 0,
          low: parseFloat(item[3]) || 0,
          close: parseFloat(item[4]) || 0,
          volume: parseFloat(item[5]) || 0
        }))
        setPriceHistory(history)
      } else if (data[0].openTime) {
        // API에서 처리된 데이터
        const history = data.map((item: any) => ({
          time: item.openTime,
          open: parseFloat(item.open) || 0,
          high: parseFloat(item.high) || 0,
          low: parseFloat(item.low) || 0,
          close: parseFloat(item.close) || 0,
          volume: parseFloat(item.volume) || 0
        }))
        setPriceHistory(history)
      }
    } catch (err) {
      console.error('Error fetching historical data:', err)
      // 에러 시 기본 빈 배열로 설정
      setPriceHistory([])
      setError(null) // 에러 메시지 숨김 (WebSocket 데이터 우선 사용)
    }
  }, [])

  // 모멘텀 지표 계산
  const calculateMomentumIndicators = (data: any[]) => {
    if (data.length < 14) return

    const closes = data.map(d => d.close)
    
    // RSI 계산
    const rsi = calculateRSI(closes, 14)
    
    // MACD 계산
    const macd = calculateMACD(closes)
    
    // Stochastic 계산
    const stochastic = calculateStochastic(data, 14, 3)
    
    // Williams %R 계산
    const williams = calculateWilliams(data, 14)
    
    // ROC 계산
    const roc = calculateROC(closes, 12)
    
    // 모멘텀 스코어 계산
    const momentumScore = calculateMomentumScore(rsi, macd, stochastic, williams, roc)
    
    // 트렌드 판단
    const trend = determineTrend(momentumScore, rsi, macd)
    
    setMomentumData({
      rsi,
      macd,
      stochastic,
      williams,
      roc,
      momentumScore,
      trend
    })
  }

  // RSI 계산
  const calculateRSI = (prices: number[], period: number = 14): number => {
    if (prices.length < period + 1) return 50

    let gains = 0
    let losses = 0

    for (let i = prices.length - period; i < prices.length; i++) {
      const change = prices[i] - prices[i - 1]
      if (change > 0) {
        gains += change
      } else {
        losses -= change
      }
    }

    const avgGain = gains / period
    const avgLoss = losses / period
    
    if (avgLoss === 0) return 100
    
    const rs = avgGain / avgLoss
    return 100 - (100 / (1 + rs))
  }

  // MACD 계산
  const calculateMACD = (prices: number[]) => {
    const ema12 = calculateEMA(prices, 12)
    const ema26 = calculateEMA(prices, 26)
    const macdLine = ema12 - ema26
    const signalLine = calculateEMA([macdLine], 9)
    
    return {
      macd: macdLine,
      signal: signalLine,
      histogram: macdLine - signalLine
    }
  }

  // EMA 계산
  const calculateEMA = (data: number[], period: number): number => {
    if (data.length < period) return data[data.length - 1]
    
    const multiplier = 2 / (period + 1)
    let ema = data.slice(0, period).reduce((a, b) => a + b) / period
    
    for (let i = period; i < data.length; i++) {
      ema = (data[i] - ema) * multiplier + ema
    }
    
    return ema
  }

  // Stochastic 계산
  const calculateStochastic = (data: any[], period: number, smooth: number) => {
    const highs = data.slice(-period).map(d => d.high)
    const lows = data.slice(-period).map(d => d.low)
    const close = data[data.length - 1].close
    
    const highest = Math.max(...highs)
    const lowest = Math.min(...lows)
    
    const k = ((close - lowest) / (highest - lowest)) * 100
    const d = k // Simplified for now
    
    return { k, d }
  }

  // Williams %R 계산
  const calculateWilliams = (data: any[], period: number): number => {
    const highs = data.slice(-period).map(d => d.high)
    const lows = data.slice(-period).map(d => d.low)
    const close = data[data.length - 1].close
    
    const highest = Math.max(...highs)
    const lowest = Math.min(...lows)
    
    return ((highest - close) / (highest - lowest)) * -100
  }

  // ROC 계산
  const calculateROC = (prices: number[], period: number): number => {
    if (prices.length < period + 1) return 0
    
    const currentPrice = prices[prices.length - 1]
    const pastPrice = prices[prices.length - 1 - period]
    
    return ((currentPrice - pastPrice) / pastPrice) * 100
  }

  // 모멘텀 스코어 계산
  const calculateMomentumScore = (
    rsi: number,
    macd: any,
    stochastic: any,
    williams: number,
    roc: number
  ): number => {
    let score = 0
    
    // RSI 점수 (0-25점)
    if (rsi > 70) score += 25
    else if (rsi > 60) score += 20
    else if (rsi > 50) score += 15
    else if (rsi > 40) score += 10
    else if (rsi > 30) score += 5
    
    // MACD 점수 (0-25점)
    if (macd.histogram > 0) score += 25
    else score += 10
    
    // Stochastic 점수 (0-25점)
    if (stochastic.k > 80) score += 25
    else if (stochastic.k > 60) score += 20
    else if (stochastic.k > 40) score += 15
    else if (stochastic.k > 20) score += 10
    else score += 5
    
    // Williams %R 점수 (0-25점)
    if (williams > -20) score += 25
    else if (williams > -40) score += 20
    else if (williams > -60) score += 15
    else if (williams > -80) score += 10
    else score += 5
    
    return Math.min(100, score)
  }

  // 트렌드 판단
  const determineTrend = (score: number, rsi: number, macd: any): MomentumData['trend'] => {
    if (score > 80 && rsi > 70) return 'strong_bullish'
    if (score > 60) return 'bullish'
    if (score < 20 && rsi < 30) return 'strong_bearish'
    if (score < 40) return 'bearish'
    return 'neutral'
  }

  // 폴링 폴백 함수
  const startPolling = useCallback((symbol: string) => {
    console.log('Starting polling for', symbol)
    
    // 기존 폴링 정리
    if (pollingIntervalRef.current) {
      clearInterval(pollingIntervalRef.current)
    }
    
    // 즉시 한 번 업데이트
    fetchTickerData(symbol)
    
    // 3초마다 가격 업데이트
    pollingIntervalRef.current = setInterval(async () => {
      try {
        await fetchTickerData(symbol)
      } catch (err) {
        console.error('Polling error:', err)
      }
    }, 3000) as any
  }, [])
  
  // 티커 데이터 가져오기 (API 라우트 사용)
  const fetchTickerData = useCallback(async (symbol: string) => {
    try {
      const response = await fetch(`/api/ticker-stream?symbol=${symbol}`)
      if (!response.ok) throw new Error('Failed to fetch ticker')
      
      const data = await response.json()
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      
      setCoinData({
        symbol: data.s,
        name: coin?.name || symbol,
        price: parseFloat(data.c),
        change24h: parseFloat(data.P),
        volume24h: parseFloat(data.v),
        high24h: parseFloat(data.h),
        low24h: parseFloat(data.l),
        marketCap: parseFloat(data.q)
      })
    } catch (err) {
      console.error('Ticker fetch error:', err)
    }
  }, [])

  // WebSocket 연결 (try-catch 강화)
  const connectWebSocket = useCallback((symbol: string) => {
    try {
      // 기존 연결 정리
      if (wsRef.current) {
        try {
          if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {
            wsRef.current.close(1000, 'Switching to new connection')
          }
        } catch (closeError) {
          console.warn('Error closing previous WebSocket:', closeError)
        }
        wsRef.current = null
      }

      // 재연결 타이머 정리
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
        reconnectTimeoutRef.current = null
      }

      const streamName = symbol.toLowerCase() + '@ticker'
      const wsUrl = `${BINANCE_CONFIG.WS_BASE}/${streamName}`
      console.log('Connecting to WebSocket:', wsUrl)
      
      let ws: WebSocket
      try {
        ws = new WebSocket(wsUrl)
      } catch (wsCreateError) {
        console.error('Failed to create WebSocket:', wsCreateError)
        setError('WebSocket 생성에 실패했습니다. 재시도 중...')
        setConnectionStatus('error')
        
        // 5초 후 재시도
        reconnectTimeoutRef.current = setTimeout(() => {
          connectWebSocket(symbol)
        }, 5000)
        return
      }
      
      wsRef.current = ws
      setConnectionStatus('connecting')

      // 연결 타임아웃 설정 (10초)
      const connectionTimeout = setTimeout(() => {
        if (ws.readyState !== WebSocket.OPEN) {
          console.error('WebSocket connection timeout')
          try {
            ws.close(1000, 'Connection timeout')
          } catch (timeoutCloseError) {
            console.warn('Error closing timed out WebSocket:', timeoutCloseError)
          }
          setError('WebSocket 연결 시간이 초과되었습니다.')
          setConnectionStatus('disconnected')
          
          // 재연결 시도
          reconnectTimeoutRef.current = setTimeout(() => {
            connectWebSocket(symbol)
          }, 5000)
        }
      }, 10000)

      ws.onopen = () => {
        clearTimeout(connectionTimeout)
        console.log('WebSocket connected:', symbol)
        setConnectionStatus('connected')
        setError(null)
      }

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data)
          
          // 데이터 유효성 검사
          if (!data || !data.s || !data.c) {
            console.warn('Invalid WebSocket data received:', data)
            return
          }
          
          const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
          setCoinData(prev => ({
            symbol: data.s,
            name: coin?.name || symbol,
            price: parseFloat(data.c) || prev?.price || 0,
            change24h: parseFloat(data.P) || prev?.change24h || 0,
            volume24h: parseFloat(data.v) || prev?.volume24h || 0,
            high24h: parseFloat(data.h) || prev?.high24h || 0,
            low24h: parseFloat(data.l) || prev?.low24h || 0,
            marketCap: parseFloat(data.q) || prev?.marketCap || 0
          }))
        } catch (parseError) {
          console.error('Error parsing WebSocket message:', parseError)
          // 파싱 에러 시에도 연결은 유지
        }
      }

      ws.onerror = (event) => {
        clearTimeout(connectionTimeout)
        console.error('WebSocket error occurred:', {
          url: wsUrl,
          readyState: ws.readyState,
          event: event
        })
        setError('WebSocket 연결 오류가 발생했습니다. 재연결 중...')
        setConnectionStatus('error')
      }

      ws.onclose = (event) => {
        clearTimeout(connectionTimeout)
        console.log('WebSocket disconnected. Code:', event.code, 'Reason:', event.reason)
        setConnectionStatus('disconnected')
        wsRef.current = null

        // 정상적인 종료가 아닌 경우 재연결 시도
        if (event.code !== 1000 && event.code !== 1001) {
          const attempts = (ws as any)?.reconnectAttempts || 0
          if (attempts < 3) {
            console.log(`Attempting to reconnect WebSocket... (attempt ${attempts + 1}/3)`)
            reconnectTimeoutRef.current = setTimeout(() => {
              const newWs = wsRef.current
              if (newWs) {
                (newWs as any).reconnectAttempts = attempts + 1
              }
              connectWebSocket(symbol)
            }, 5000)
          } else {
            console.log('WebSocket reconnection failed, using fallback')
            setError('실시간 연결이 불안정합니다. 대체 방식으로 데이터를 가져옵니다.')
            // 폴링 대신 기본값으로 폴백
            fetchCoinDataWithRateLimit(symbol)
          }
        }
      }
    } catch (error) {
      console.error('Error in WebSocket setup:', error)
      setError('WebSocket 설정 중 오류가 발생했습니다.')
      setConnectionStatus('error')
      
      // 에러 시 기본값으로 폴백
      const coin = SUPPORTED_COINS.find(c => c.symbol === symbol)
      const defaultPrice = coin?.symbol === 'BTCUSDT' ? 98000 :
                          coin?.symbol === 'ETHUSDT' ? 3500 :
                          coin?.symbol === 'BNBUSDT' ? 700 : 0
      
      setCoinData({
        symbol: symbol,
        name: coin?.name || symbol,
        price: defaultPrice,
        change24h: 0,
        volume24h: 0,
        high24h: defaultPrice * 1.05,
        low24h: defaultPrice * 0.95,
        marketCap: 0
      })
      
      // 재연결 시도
      reconnectTimeoutRef.current = setTimeout(() => {
        connectWebSocket(symbol)
      }, 5000)
    }
  }, [selectedCoin, fetchCoinDataWithRateLimit])

  // 코인 변경 시
  useEffect(() => {
    setLoading(true)
    setError(null)
    
    // 데이터 초기화하지 않고 유지 (깜빡임 방지)
    // setCoinData(null)
    // setMomentumData(null)
    // setPriceHistory([])
    
    // 히스토리컬 데이터 즉시 가져오기
    fetchHistoricalData(selectedCoin)
    
    // WebSocket이 연결되지 않았을 때만 REST API 사용
    if (!isConnected) {
      fetchCoinDataWithRateLimit(selectedCoin)
    }
    
    // 로딩 완료 (더 빠르게)
    const timer = setTimeout(() => setLoading(false), 500)
    
    return () => {
      clearTimeout(timer)
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
    }
  }, [selectedCoin, isConnected, fetchCoinDataWithRateLimit, fetchHistoricalData])

  // 가격 히스토리 업데이트 시 모멘텀 지표 계산
  useEffect(() => {
    if (priceHistory.length >= 14) {
      calculateMomentumIndicators(priceHistory)
    }
  }, [priceHistory])

  // WebSocket 연결 상태 업데이트
  useEffect(() => {
    setConnectionStatus(isConnected ? 'connected' : 'disconnected')
  }, [isConnected])

  // 컴포넌트 언마운트 시 정리
  useEffect(() => {
    return () => {
      if (wsRef.current) {
        wsRef.current.close(1000, 'Component unmounting')
      }
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current)
      }
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current)
      }
    }
  }, [])

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin mx-auto mb-4"></div>
          <p className="text-gray-400">모멘텀 데이터 분석 중...</p>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900 flex items-center justify-center">
        <div className="text-center bg-red-500/10 border border-red-500/20 rounded-lg p-6">
          <p className="text-red-400 mb-2">오류 발생</p>
          <p className="text-gray-400">{error}</p>
          <button 
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-lg transition-colors"
          >
            새로고침
          </button>
        </div>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 via-black to-gray-900">
      {/* 코인 선택기 */}
      <CoinSelector 
        coins={SUPPORTED_COINS}
        selectedCoin={selectedCoin}
        onSelectCoin={setSelectedCoin}
        coinData={coinData}
      />

      {/* WebSocket 연결 상태 */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-2 pb-0">
        <div className="flex items-center justify-end gap-2 text-sm">
          <div className={`flex items-center gap-2 ${
            isConnected ? 'text-green-400' : 
            connectionStatus === 'connecting' ? 'text-yellow-400' : 
            connectionStatus === 'error' ? 'text-red-400' : 'text-gray-400'
          }`}>
            <div className={`w-2 h-2 rounded-full ${
              isConnected ? 'bg-green-400' : 
              connectionStatus === 'connecting' ? 'bg-yellow-400 animate-pulse' : 
              connectionStatus === 'error' ? 'bg-red-400' : 'bg-gray-400'
            }`} />
            <span>
              {connectionStatus === 'connected' ? '실시간 데이터 수신 중' :
               connectionStatus === 'connecting' ? '데이터 연결 중...' :
               connectionStatus === 'error' ? '연결 오류' : '연결 끊김'}
            </span>
          </div>
          {error && (
            <div className="text-red-400 text-xs">
              {error}
            </div>
          )}
        </div>
      </div>

      {/* 메인 대시보드 */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6">
        {/* 모멘텀 개요 */}
        <MomentumOverview coinData={coinData} momentumData={momentumData} />

        {/* 가격 차트 */}
        <PriceChart 
          symbol={selectedCoin}
          priceHistory={priceHistory}
          currentPrice={coinData?.price || 0}
          momentumData={momentumData}
        />

        {/* 모멘텀 지표 */}
        <MomentumIndicators momentumData={momentumData} />

        {/* 거래량 분석 */}
        <VolumeAnalysis 
          symbol={selectedCoin}
          volumeData={priceHistory}
        />

        {/* 추세 강도 */}
        <TrendStrength 
          momentumData={momentumData}
          priceHistory={priceHistory}
        />

        {/* 신호 생성기 */}
        <SignalGenerator 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* 포지션 사이저 */}
        <PositionSizer 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* 리스크 관리 */}
        <RiskManager 
          momentumData={momentumData}
          coinData={coinData}
        />

        {/* 백테스팅 결과 */}
        <BacktestResults 
          symbol={selectedCoin}
          priceHistory={priceHistory}
        />

        {/* 실시간 성과 */}
        <LivePerformance 
          symbol={selectedCoin}
          momentumData={momentumData}
        />

        {/* 종합 트레이딩 전략 */}
        <TradingStrategy 
          momentumData={momentumData}
          coinData={coinData}
        />
      </div>
    </div>
  )
}