'use client'

import { useEffect, useState, useRef } from 'react'
import { safeFixed, safePrice, safeAmount, safePercent, safeMillion, safeThousand } from '@/lib/safeFormat'

interface MarketProfileProps {
  symbol: string
}

interface ProfileLevel {
  price: number
  volume: number
  tpo: number // Time Price Opportunity
  isVA: boolean // Value Area
  isPOC: boolean // Point of Control
}

interface ProfileData {
  levels: ProfileLevel[]
  poc: number
  vah: number // Value Area High
  val: number // Value Area Low
  totalVolume: number
}

export default function MarketProfile({ symbol }: MarketProfileProps) {
  const [profileData, setProfileData] = useState<ProfileData | null>(null)
  const [currentPrice, setCurrentPrice] = useState(0)
  const [isLoading, setIsLoading] = useState(true)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)
  const canvasRef = useRef<HTMLCanvasElement | null>(null)

  useEffect(() => {
    const fetchProfileData = async () => {
      try {
        // Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ÏôÄ Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        const [klinesResponse, tradesResponse] = await Promise.all([
          fetch(`/api/binance/klines?symbol=${symbol}&interval=5m&limit=24`), // 2ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞
          fetch(`/api/binance/trades?symbol=${symbol}&limit=500`)
        ])

        if (!klinesResponse.ok || !tradesResponse.ok) {
          throw new Error('Failed to fetch data')
        }

        const klines = await klinesResponse.json()
        const trades = await tradesResponse.json()

        // ÌòÑÏû¨ Í∞ÄÍ≤©
        const lastKline = klines[klines.length - 1]
        setCurrentPrice(parseFloat(lastKline[4])) // close price

        // Í∞ÄÍ≤© Î≤îÏúÑ Í≥ÑÏÇ∞
        let highPrice = 0
        let lowPrice = Infinity
        
        klines.forEach((kline: any[]) => {
          const high = parseFloat(kline[2])
          const low = parseFloat(kline[3])
          if (high > highPrice) highPrice = high
          if (low < lowPrice) lowPrice = low
        })

        // Í∞ÄÍ≤© Î†àÎ≤® ÏÉùÏÑ± (30Í∞ú)
        const levels: ProfileLevel[] = []
        const priceStep = (highPrice - lowPrice) / 30
        const volumeMap = new Map<number, number>()
        let totalVolume = 0

        for (let i = 0; i < 30; i++) {
          const price = lowPrice + (priceStep * i)
          volumeMap.set(Math.round(price * 100) / 100, 0)
        }

        // Í±∞ÎûòÎüâ Ìï†Îãπ
        trades.forEach((trade: any) => {
          const tradePrice = parseFloat(trade.p)
          const tradeVolume = parseFloat(trade.q)
          totalVolume += tradeVolume

          // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Í∞ÄÍ≤© Î†àÎ≤® Ï∞æÍ∏∞
          let closestPrice = 0
          let minDiff = Infinity

          volumeMap.forEach((_, price) => {
            const diff = Math.abs(price - tradePrice)
            if (diff < minDiff) {
              minDiff = diff
              closestPrice = price
            }
          })

          volumeMap.set(closestPrice, (volumeMap.get(closestPrice) || 0) + tradeVolume)
        })

        // POC (Point of Control) Ï∞æÍ∏∞
        let maxVolume = 0
        let poc = 0
        
        volumeMap.forEach((volume, price) => {
          if (volume > maxVolume) {
            maxVolume = volume
            poc = price
          }
        })

        // Value Area Í≥ÑÏÇ∞ (70% Í±∞ÎûòÎüâ Ìè¨Ìï® Íµ¨Ïó≠)
        const sortedLevels = Array.from(volumeMap.entries())
          .sort((a, b) => b[1] - a[1])
        
        let vaVolume = 0
        const vaTarget = totalVolume * 0.7
        const vaLevels: number[] = []
        
        for (const [price, volume] of sortedLevels) {
          if (vaVolume < vaTarget) {
            vaVolume += volume
            vaLevels.push(price)
          } else {
            break
          }
        }

        const vah = Math.max(...vaLevels)
        const val = Math.min(...vaLevels)

        // TPO Í≥ÑÏÇ∞ (Time Price Opportunity)
        const tpoMap = new Map<number, number>()
        klines.forEach((kline: any[]) => {
          const high = parseFloat(kline[2])
          const low = parseFloat(kline[3])
          
          volumeMap.forEach((_, price) => {
            if (price >= low && price <= high) {
              tpoMap.set(price, (tpoMap.get(price) || 0) + 1)
            }
          })
        })

        // ProfileLevel Î∞∞Ïó¥ ÏÉùÏÑ±
        volumeMap.forEach((volume, price) => {
          levels.push({
            price,
            volume,
            tpo: tpoMap.get(price) || 0,
            isVA: vaLevels.includes(price),
            isPOC: price === poc
          })
        })

        levels.sort((a, b) => b.price - a.price)

        setProfileData({
          levels,
          poc,
          vah,
          val,
          totalVolume
        })
        setIsLoading(false)
      } catch (error) {
        console.error('MarketProfile data fetch error:', error)
        setIsLoading(false)
      }
    }

    fetchProfileData()
    intervalRef.current = setInterval(fetchProfileData, 10000) // 10Ï¥àÎßàÎã§ ÏóÖÎç∞Ïù¥Ìä∏

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current)
    }
  }, [symbol])

  // Ï∫îÎ≤ÑÏä§Ïóê ÌîÑÎ°úÌååÏùº Í∑∏Î¶¨Í∏∞
  useEffect(() => {
    if (!canvasRef.current || !profileData) return

    const canvas = canvasRef.current
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
    const rect = canvas.getBoundingClientRect()
    canvas.width = rect.width * window.devicePixelRatio
    canvas.height = rect.height * window.devicePixelRatio
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio)

    // ÌÅ¥Î¶¨Ïñ¥
    ctx.clearRect(0, 0, rect.width, rect.height)

    const padding = 10
    const priceWidth = 80
    const chartWidth = rect.width - priceWidth - padding * 2
    const chartHeight = rect.height - padding * 2
    const levelHeight = chartHeight / profileData.levels.length

    // ÏµúÎåÄ Î≥ºÎ•® Ï∞æÍ∏∞
    const maxVolume = Math.max(...profileData.levels.map(l => l.volume))

    profileData.levels.forEach((level, index) => {
      const y = padding + index * levelHeight
      const barWidth = (level.volume / maxVolume) * chartWidth * 0.8
      
      // Value Area Î∞∞Í≤Ω
      if (level.isVA) {
        ctx.fillStyle = 'rgba(139, 92, 246, 0.1)'
        ctx.fillRect(priceWidth, y, chartWidth, levelHeight)
      }

      // Î≥ºÎ•® Î∞î
      if (level.isPOC) {
        ctx.fillStyle = 'rgba(236, 72, 153, 0.8)' // POCÎäî ÌïëÌÅ¨ÏÉâ
      } else if (level.isVA) {
        ctx.fillStyle = 'rgba(139, 92, 246, 0.6)' // VAÎäî Î≥¥ÎùºÏÉâ
      } else {
        ctx.fillStyle = 'rgba(75, 85, 99, 0.6)' // ÏùºÎ∞òÏùÄ ÌöåÏÉâ
      }
      
      ctx.fillRect(priceWidth, y + levelHeight * 0.2, barWidth, levelHeight * 0.6)

      // ÌòÑÏû¨ Í∞ÄÍ≤© ÌëúÏãú
      if (profileData.levels.length > 1) {
        const priceDiff = Math.abs(profileData.levels[1].price - profileData.levels[0].price)
        if (Math.abs(level.price - currentPrice) < priceDiff) {
          ctx.fillStyle = 'rgba(34, 197, 94, 0.3)'
          ctx.fillRect(0, y, rect.width, levelHeight)
        }
      }

      // Í∞ÄÍ≤© ÌÖçÏä§Ìä∏
      ctx.fillStyle = level.isPOC ? '#ec4899' : '#9ca3af'
      ctx.font = '11px sans-serif'
      ctx.textAlign = 'right'
      ctx.textBaseline = 'middle'
      ctx.fillText(`$${safePrice(level.price, 2)}`, priceWidth - 5, y + levelHeight / 2)

      // POC ÌëúÏãú
      if (level.isPOC) {
        ctx.fillStyle = '#ec4899'
        ctx.font = 'bold 10px sans-serif'
        ctx.textAlign = 'left'
        ctx.fillText('POC', priceWidth + barWidth + 5, y + levelHeight / 2)
      }
    })

    // VAH/VAL ÎùºÏù∏
    const vahIndex = profileData.levels.findIndex(l => l.price === profileData.vah)
    const valIndex = profileData.levels.findIndex(l => l.price === profileData.val)

    ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)'
    ctx.lineWidth = 2
    ctx.setLineDash([5, 5])

    // VAH
    if (vahIndex >= 0) {
      const y = padding + vahIndex * levelHeight
      ctx.beginPath()
      ctx.moveTo(priceWidth, y)
      ctx.lineTo(rect.width - padding, y)
      ctx.stroke()

      ctx.fillStyle = '#8b5cf6'
      ctx.font = '10px sans-serif'
      ctx.textAlign = 'right'
      ctx.fillText('VAH', priceWidth - 5, y - 5)
    }

    // VAL
    if (valIndex >= 0) {
      const y = padding + (valIndex + 1) * levelHeight
      ctx.beginPath()
      ctx.moveTo(priceWidth, y)
      ctx.lineTo(rect.width - padding, y)
      ctx.stroke()

      ctx.fillStyle = '#8b5cf6'
      ctx.font = '10px sans-serif'
      ctx.textAlign = 'right'
      ctx.fillText('VAL', priceWidth - 5, y + 12)
    }

    ctx.setLineDash([])

  }, [profileData, currentPrice])

  if (isLoading) {
    return (
      <div className="bg-gray-900/50 backdrop-blur-lg rounded-xl p-6 border border-purple-500/20">
        <div className="animate-pulse">
          <div className="h-8 bg-gray-700 rounded mb-4 w-48"></div>
          <div className="h-96 bg-gray-700 rounded"></div>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-gray-900/50 backdrop-blur-lg rounded-xl p-6 border border-purple-500/20">
      <div className="flex justify-between items-start mb-6">
        <h3 className="text-xl font-bold text-white flex items-center gap-2">
          <span className="text-2xl">üìä</span>
          ÎßàÏºì ÌîÑÎ°úÌååÏùº
        </h3>
        <div className="text-right">
          <p className="text-sm text-gray-400">ÌòÑÏû¨Í∞Ä</p>
          <p className="text-lg font-bold text-white">${safePrice(currentPrice, 2)}</p>
        </div>
      </div>

      {/* ÌîÑÎ°úÌååÏùº Ï∞®Ìä∏ */}
      <div className="relative h-96 mb-4">
        <canvas
          ref={canvasRef}
          className="w-full h-full"
          style={{ imageRendering: 'crisp-edges' }}
        />
      </div>

      {/* ÏßÄÌëú ÏöîÏïΩ */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div className="text-center">
          <p className="text-xs text-gray-400">POC</p>
          <p className="text-lg font-bold text-pink-400">${profileData?.safeFixed(poc, 2)}</p>
        </div>
        <div className="text-center">
          <p className="text-xs text-gray-400">VAH</p>
          <p className="text-lg font-bold text-purple-400">${profileData?.safeFixed(vah, 2)}</p>
        </div>
        <div className="text-center">
          <p className="text-xs text-gray-400">VAL</p>
          <p className="text-lg font-bold text-purple-400">${profileData?.safeFixed(val, 2)}</p>
        </div>
        <div className="text-center">
          <p className="text-xs text-gray-400">VA Range</p>
          <p className="text-lg font-bold text-gray-300">
            {profileData && ((profileData.vah - profileData.val) / profileData.val * 100).toFixed(2)}%
          </p>
        </div>
      </div>

      {/* ÌîÑÎ°úÌååÏùº Ìï¥ÏÑù */}
      <div className="p-4 bg-gray-800/50 rounded-lg">
        <h4 className="text-sm font-medium text-purple-400 mb-2">üìê ÎßàÏºì ÌîÑÎ°úÌååÏùº Ìä∏Î†àÏù¥Îî© Ï†ÑÎûµ</h4>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-xs text-gray-300">
          <div>
            <p className="font-medium text-gray-200 mb-1">ÌòÑÏû¨ ÏúÑÏπò Î∂ÑÏÑù</p>
            {currentPrice > (profileData?.vah || 0) && (
              <div className="space-y-1">
                <p className="text-yellow-400">‚Ä¢ VAH ÏúÑ - Í∞ïÌïú ÏÉÅÏäπÏÑ∏</p>
                <p>‚Ä¢ Ï∂îÍ∞Ä ÏÉÅÏäπ Í∞ÄÎä•ÌïòÎÇò Ï†ÄÌï≠ ÏòàÏÉÅ</p>
                <p className="text-green-400 font-medium">üí° Îã®Í∏∞ Ïàè ÎòêÎäî Ïù¥ÏùµÏã§ÌòÑ</p>
              </div>
            )}
            {currentPrice <= (profileData?.vah || 0) && currentPrice >= (profileData?.val || 0) && (
              <div className="space-y-1">
                <p className="text-blue-400">‚Ä¢ VA ÎÇ¥Î∂Ä - Í∑†Ìòï Íµ¨Í∞Ñ</p>
                <p>‚Ä¢ POC Í∑ºÏ≤òÏóêÏÑú ÏßÄÏßÄ/Ï†ÄÌï≠</p>
                <p className="text-gray-400 font-medium">üí° POC Í∏∞Ï§Ä Îã®ÌÉÄ Îß§Îß§</p>
              </div>
            )}
            {currentPrice < (profileData?.val || 0) && (
              <div className="space-y-1">
                <p className="text-yellow-400">‚Ä¢ VAL ÏïÑÎûò - ÏïΩÏÑ∏ Íµ¨Í∞Ñ</p>
                <p>‚Ä¢ VAL ÌöåÎ≥µ ÏãúÎèÑ Ï£ºÎ™©</p>
                <p className="text-green-400 font-medium">üí° Î∞òÎì± Îß§Ïàò Í∏∞Ìöå</p>
              </div>
            )}
          </div>
          <div>
            <p className="font-medium text-gray-200 mb-1">ÌîÑÎ°úÌååÏùº ÌòïÌÉú Ìï¥ÏÑù</p>
            <ul className="space-y-1">
              <li>‚Ä¢ <span className="text-purple-400">POC</span>: Í∞ÄÏû• ÎßéÏù¥ Í±∞ÎûòÎêú Í∞ÄÍ≤© (Í∞ïÌïú ÏßÄÏßÄ/Ï†ÄÌï≠)</li>
              <li>‚Ä¢ <span className="text-purple-400">VA</span>: 70% Í±∞Îûò Î∞úÏÉù Íµ¨Í∞Ñ (Í≥µÏ†ï Í∞ÄÏπò)</li>
              <li>‚Ä¢ <span className="text-green-400">DÌòï ÌîÑÎ°úÌååÏùº</span>: Ìä∏Î†åÎìú ÏãúÏûë</li>
              <li>‚Ä¢ <span className="text-blue-400">PÌòï ÌîÑÎ°úÌååÏùº</span>: Í∑†Ìòï ÏÉÅÌÉú</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  )
}